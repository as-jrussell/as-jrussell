üîß Initial Setup Log - 20250805_1030
üöÄ Running on psqltstawrd01.clm0vrvchewi.us-east-2.rds.amazonaws.com...
=== psqltstawrd01.clm0vrvchewi.us-east-2.rds.amazonaws.com ===
‚úÖ DBA found. Executing against DBA...
üìÑ [DBA] /c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/1 initial/DBA_database_creation.sql
üîó Running: psql -U "jrussell" -h "psqltstawrd01.clm0vrvchewi.us-east-2.rds.amazonaws.com" -p "5432" -d DBA -f "/c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/1 initial/DBA_database_creation.sql"
psql: error: connection to server at "psqltstawrd01.clm0vrvchewi.us-east-2.rds.amazonaws.com" (172.31.26.43), port 5432 failed: FATAL:  database "DBA" does not exist
‚ùå ERROR running /c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/1 initial/DBA_database_creation.sql against DBA
--- FAILED COMMAND ---
psql -U "jrussell" -h "psqltstawrd01.clm0vrvchewi.us-east-2.rds.amazonaws.com" -p "5432" -d DBA -f "/c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/1 initial/DBA_database_creation.sql"
--- BEGIN FAILED SCRIPT: /c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/1 initial/DBA_database_creation.sql ---

-- ============================================
-- Script: DBA_database_creation.sql
-- Purpose: Create the 'DBA' database using template0
-- ============================================
set role dbadmin;

set role dbadmin;

-- Set default db name.
-- We now set the variable to a string that includes the double quotes.
\if :{?dbname}
    -- User provided a name, assume it's already quoted or correctly capitalized
    -- and we will pass it through.
    \echo Using user-provided database name: :dbname
\else
    -- Default to "DBA" by setting the variable to the quoted string.
    \set dbname '"DBA"'
    \echo Using default database name: :dbname
\endif


-- Confirm variable
\echo Final database name: :dbname

-- Use the variable directly. It already contains the necessary quotes.
CREATE DATABASE :dbname
    WITH OWNER = dbadmin
    TEMPLATE = template0
    ENCODING = 'UTF8'
    LC_COLLATE = 'en_US.UTF-8'
    LC_CTYPE = 'en_US.UTF-8'
    CONNECTION LIMIT = -1;


GRANT TEMPORARY, CONNECT ON DATABASE :dbname TO PUBLIC;

GRANT ALL ON DATABASE :dbname  TO dba_team WITH GRANT OPTION;

GRANT ALL ON DATABASE :dbname TO dbadmin;


GRANT CREATE ON DATABASE :dbname TO dba_team;--- END FAILED SCRIPT ---
üìÑ [DBA] /c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/1 initial/Schema_creation.sql
üîó Running: psql -U "jrussell" -h "psqltstawrd01.clm0vrvchewi.us-east-2.rds.amazonaws.com" -p "5432" -d DBA -f "/c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/1 initial/Schema_creation.sql"
psql: error: connection to server at "psqltstawrd01.clm0vrvchewi.us-east-2.rds.amazonaws.com" (172.31.26.43), port 5432 failed: FATAL:  database "DBA" does not exist
‚ùå ERROR running /c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/1 initial/Schema_creation.sql against DBA
--- FAILED COMMAND ---
psql -U "jrussell" -h "psqltstawrd01.clm0vrvchewi.us-east-2.rds.amazonaws.com" -p "5432" -d DBA -f "/c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/1 initial/Schema_creation.sql"
--- BEGIN FAILED SCRIPT: /c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/1 initial/Schema_creation.sql ---
-- ‚úÖ PostgreSQL-Compatible Schema Creation Script
-- Filename: 03_Schema_creation.sql

-- ============================================================
-- STEP 1: Create 'info' schema if not exists and grant privileges
-- ============================================================
set role dba_team; 

DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_namespace WHERE nspname = 'info') THEN
        EXECUTE 'CREATE SCHEMA info AUTHORIZATION dba_team';
        RAISE NOTICE 'Schema "info" created.';
    ELSE
        RAISE NOTICE 'Schema "info" already exists.';
    END IF;
END
$$;

-- Grant privileges on the 'info' schema
GRANT USAGE ON SCHEMA info TO db_datareader;
GRANT USAGE ON SCHEMA info TO db_datawriter;
GRANT USAGE ON SCHEMA info TO db_ddladmin;




GRANT SELECT ON ALL TABLES IN SCHEMA info TO db_datareader;
GRANT DELETE, INSERT, SELECT, UPDATE ON ALL TABLES IN SCHEMA info TO db_datawriter;
GRANT ALL ON ALL TABLES IN SCHEMA info TO db_ddladmin;

GRANT EXECUTE ON ALL FUNCTIONS IN SCHEMA info TO db_datareader;
GRANT EXECUTE ON ALL FUNCTIONS IN SCHEMA info TO db_datawriter;
GRANT EXECUTE ON ALL FUNCTIONS IN SCHEMA info TO db_ddladmin;

-- ============================================================
-- STEP 2: Create 'deploy' schema if not exists and grant privileges
-- ============================================================

DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_namespace WHERE nspname = 'deploy') THEN
        EXECUTE 'CREATE SCHEMA deploy AUTHORIZATION dba_team';
        RAISE NOTICE 'Schema "deploy" created.';
    ELSE
        RAISE NOTICE 'Schema "deploy" already exists.';
    END IF;
END
$$;

-- Grant privileges on the 'deploy' schema
GRANT USAGE ON SCHEMA deploy TO dba_team;
GRANT INSERT, SELECT, UPDATE ON ALL TABLES IN SCHEMA deploy TO dba_team;
GRANT EXECUTE ON ALL FUNCTIONS IN SCHEMA deploy TO dba_team;
REVOKE ALL ON SCHEMA deploy FROM PUBLIC;




CREATE SCHEMA IF NOT EXISTS admin AUTHORIZATION dba_team;


-- Grant access to expected roles
GRANT USAGE ON SCHEMA admin TO dba_team;
GRANT INSERT, SELECT, UPDATE ON ALL TABLES IN SCHEMA admin TO dba_team;
GRANT EXECUTE ON ALL FUNCTIONS IN SCHEMA admin TO dba_team;
REVOKE ALL ON SCHEMA admin FROM PUBLIC;

--- END FAILED SCRIPT ---
üìÑ [DBA] /c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/1 initial/Tablecreations.sql
üîó Running: psql -U "jrussell" -h "psqltstawrd01.clm0vrvchewi.us-east-2.rds.amazonaws.com" -p "5432" -d DBA -f "/c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/1 initial/Tablecreations.sql"
psql: error: connection to server at "psqltstawrd01.clm0vrvchewi.us-east-2.rds.amazonaws.com" (172.31.26.43), port 5432 failed: FATAL:  database "DBA" does not exist
‚ùå ERROR running /c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/1 initial/Tablecreations.sql against DBA
--- FAILED COMMAND ---
psql -U "jrussell" -h "psqltstawrd01.clm0vrvchewi.us-east-2.rds.amazonaws.com" -p "5432" -d DBA -f "/c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/1 initial/Tablecreations.sql"
--- BEGIN FAILED SCRIPT: /c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/1 initial/Tablecreations.sql ---
-- ‚úÖ PostgreSQL-Compatible Audit Log Table Creation
-- Filename: 04_tablecreations.sql

-- ================================================================
-- Create: info.account_log_history with auto-incrementing log_id
-- ================================================================
set role dba_team; 

DO $$
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.tables 
        WHERE table_schema = 'info' AND table_name = 'account_log_history'
    ) THEN
        EXECUTE '
CREATE SEQUENCE IF NOT EXISTS info.account_log_history_log_id_seq
    START WITH 1
    INCREMENT BY 1;

CREATE TABLE IF NOT EXISTS info.account_log_history (
    log_id INTEGER NOT NULL DEFAULT nextval(''info.account_log_history_log_id_seq''),
    log_timestamp TIMESTAMPTZ DEFAULT now(),
    action_type TEXT COLLATE pg_catalog."default" NOT NULL,
    target_entity TEXT COLLATE pg_catalog."default" NOT NULL,
    associated_entity TEXT COLLATE pg_catalog."default",
    status TEXT COLLATE pg_catalog."default" NOT NULL,
    sql_command TEXT COLLATE pg_catalog."default",
    message TEXT COLLATE pg_catalog."default",
    CONSTRAINT account_log_history_pkey PRIMARY KEY (log_id)
)
TABLESPACE pg_default;

ALTER SEQUENCE info.account_log_history_log_id_seq
OWNED BY info.account_log_history.log_id;

ALTER TABLE IF EXISTS info.account_log_history
    OWNER TO dba_team;

GRANT SELECT ON TABLE info.account_log_history TO db_datareader;
GRANT ALL ON TABLE info.account_log_history TO db_ddladmin;
GRANT ALL ON TABLE info.account_log_history TO dba_team;
        ';
        RAISE NOTICE 'Table "info.account_log_history" created.';
    ELSE
        RAISE NOTICE 'Table "info.account_log_history" already exists.';
    END IF;
END
$$;

-- ================================================================
-- Create: info.object_log_history
-- ================================================================

DO $$
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.tables 
        WHERE table_schema = 'info' AND table_name = 'object_log_history'
    ) THEN
        EXECUTE '
CREATE TABLE IF NOT EXISTS info.object_log_history (
    log_id SERIAL PRIMARY KEY,
    log_timestamp TIMESTAMPTZ DEFAULT now(),
    action_type TEXT NOT NULL,
    target_entity TEXT NOT NULL,
    associated_entity TEXT,
    status TEXT NOT NULL,
    sql_command TEXT,
    message TEXT
);

ALTER TABLE IF EXISTS info.object_log_history
    OWNER TO dba_team;

GRANT ALL ON TABLE info.object_log_history TO db_datareader;
GRANT SELECT ON TABLE info.object_log_history TO db_datareader;
GRANT ALL ON TABLE info.object_log_history TO dba_team;
        ';
        RAISE NOTICE 'Table "info.object_log_history" created.';
    ELSE
        RAISE NOTICE 'Table "info.object_log_history" already exists.';
    END IF;
END
$$;
--- END FAILED SCRIPT ---
üìÑ [DBA] /c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/1 initial/model_database_creation.sql
üîó Running: psql -U "jrussell" -h "psqltstawrd01.clm0vrvchewi.us-east-2.rds.amazonaws.com" -p "5432" -d DBA -f "/c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/1 initial/model_database_creation.sql"
psql: error: connection to server at "psqltstawrd01.clm0vrvchewi.us-east-2.rds.amazonaws.com" (172.31.26.43), port 5432 failed: FATAL:  database "DBA" does not exist
‚ùå ERROR running /c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/1 initial/model_database_creation.sql against DBA
--- FAILED COMMAND ---
psql -U "jrussell" -h "psqltstawrd01.clm0vrvchewi.us-east-2.rds.amazonaws.com" -p "5432" -d DBA -f "/c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/1 initial/model_database_creation.sql"
--- BEGIN FAILED SCRIPT: /c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/1 initial/model_database_creation.sql ---

-- ============================================
-- Script: model_database_creation.sql
-- Purpose: Create a 'model' database using template0 and load schema for reuse
-- ============================================
set role dbadmin;

-- Set default db name.
-- We now set the variable to a string that includes the double quotes.
\if :{?modeldbname}
    -- User provided a name, assume it's already quoted or correctly capitalized
    -- and we will pass it through.
    \echo Using user-provided database name: :modeldbname
\else
    -- Default to "DBA" by setting the variable to the quoted string.
    \set modeldbname 'model'
    \echo Using default database name: :modeldbname
\endif
-- Confirm variable
\echo Final database name: :modeldbname


CREATE DATABASE :"modeldbname"
    WITH OWNER = dbadmin
    ENCODING = 'UTF8'
    LC_COLLATE = 'en_US.UTF-8'
    LC_CTYPE = 'en_US.UTF-8'
    TEMPLATE template0;
\connect :modeldbname

-- Load schema
--
-- PostgreSQL database dump
--

-- Dumped from database version 17.5
-- Dumped by pg_dump version 17.5
set role dba_team;
SET statement_timeout = 0;
SET lock_timeout = 0;
SET idle_in_transaction_session_timeout = 0;
SET transaction_timeout = 0;
SET client_encoding = 'UTF8';
SET standard_conforming_strings = on;
SELECT pg_catalog.set_config('search_path', '', false);
SET check_function_bodies = false;
SET xmloption = content;
SET client_min_messages = warning;
SET row_security = off;

--
-- Name: dba; Type: SCHEMA; Schema: -; Owner: dba_team
--

CREATE SCHEMA IF NOT EXISTS dba;


ALTER SCHEMA dba OWNER TO dba_team;

--
-- Name: getprivileges(text); Type: FUNCTION; Schema: dba; Owner: dba_team
--
CREATE OR REPLACE FUNCTION dba.getprivileges(p_role text DEFAULT ''::text) RETURNS TABLE(object_scope text, grantee text, privilege text, inherited_role text, source text)
    LANGUAGE plpgsql
    AS $_$
    DECLARE
        v_ver INT := current_setting('server_version_num')::INT;
    BEGIN
        RETURN QUERY
        -- CTE to get roles and their directly inherited roles
        WITH inherited_roles AS (
            SELECT
                r.rolname AS role_name,
                string_agg(m.rolname, ',' ORDER BY m.rolname) AS inherited_role
            FROM pg_roles r
            LEFT JOIN pg_auth_members am ON r.oid = am.member
            LEFT JOIN pg_roles m ON am.roleid = m.oid
            GROUP BY r.rolname
        ),
        -- CTE for schema CREATE privileges
        schema_create AS (
            SELECT
                n.nspname::TEXT AS object_scope,
                r.rolname::TEXT AS grantee,
                'CREATE'::TEXT AS privilege,
                ir.inherited_role,
                'actual_schema_privilege'::TEXT AS source
            FROM pg_namespace n
            JOIN pg_roles r ON has_schema_privilege(r.rolname, n.oid, 'CREATE')
            LEFT JOIN inherited_roles ir ON r.rolname = ir.role_name
            WHERE n.nspname NOT LIKE 'pg_%' AND n.nspname <> 'information_schema'
        ),
        -- CTE for schema USAGE privileges
        schema_usage AS (
            SELECT
                n.nspname::TEXT AS object_scope,
                r.rolname::TEXT AS grantee,
                'USAGE'::TEXT AS privilege,
                ir.inherited_role,
                'actual_schema_privilege'::TEXT AS source
            FROM pg_namespace n
            JOIN pg_roles r ON has_schema_privilege(r.rolname, n.oid, 'USAGE')
            LEFT JOIN inherited_roles ir ON r.rolname = ir.role_name
            WHERE n.nspname NOT LIKE 'pg_%' AND n.nspname <> 'information_schema'
        ),
        -- CTE for database-level privileges (CREATE, TEMP, CONNECT)
        db_privs AS (
            SELECT
                current_database()::TEXT AS object_scope,
                r.rolname::TEXT AS grantee,
                unnest(string_to_array(
                    TRIM(BOTH ',' FROM
                        CASE WHEN has_database_privilege(r.rolname, current_database(), 'CREATE') THEN 'CREATE,' ELSE '' END ||
                        CASE WHEN has_database_privilege(r.rolname, current_database(), 'TEMP') THEN 'TEMP,' ELSE '' END ||
                        CASE WHEN has_database_privilege(r.rolname, current_database(), 'CONNECT') THEN 'CONNECT' ELSE '' END
                    ), ','))::TEXT AS privilege,
                ir.inherited_role,
                'actual_database_privilege'::TEXT AS source
            FROM pg_roles r
            LEFT JOIN inherited_roles ir ON r.rolname = ir.role_name
        ),
        -- CTE to extract raw ACL entries from pg_default_acl for PG 14+
        raw_acls AS (
            SELECT
                pda.defaclnamespace::regnamespace::TEXT AS object_scope,
                (regexp_matches(acl_entry::TEXT, '^(.+?)=([a-zA-Z]*)/?(.+)?$'))[1]::TEXT AS grantee,
                (regexp_matches(acl_entry::TEXT, '^(.+?)=([a-zA-Z]*)/?(.+)?$'))[2]::TEXT AS privs_raw
            FROM pg_default_acl pda, unnest(pda.defaclacl) AS acl_entry
            WHERE current_setting('server_version_num')::INT >= 140000
        ),
        -- CTE to expand raw ACL characters into full privilege names
        expanded_acls AS (
            SELECT
                ra.object_scope,
                ra.grantee,
                CASE
                    WHEN ra.privs_raw IS NULL THEN NULL
                    ELSE array_to_string(ARRAY(
                        SELECT priv_subquery.privilege FROM (
                            SELECT CASE WHEN ra.privs_raw LIKE '%a%' THEN 'INSERT' END AS privilege
                            UNION ALL SELECT CASE WHEN ra.privs_raw LIKE '%r%' THEN 'SELECT' END
                            UNION ALL SELECT CASE WHEN ra.privs_raw LIKE '%w%' THEN 'UPDATE' END
                            UNION ALL SELECT CASE WHEN ra.privs_raw LIKE '%d%' THEN 'DELETE' END
                            UNION ALL SELECT CASE WHEN ra.privs_raw LIKE '%D%' THEN 'TRUNCATE' END
                            UNION ALL SELECT CASE WHEN ra.privs_raw LIKE '%x%' THEN 'REFERENCES' END
                            UNION ALL SELECT CASE WHEN ra.privs_raw LIKE '%t%' THEN 'TRIGGER' END
                            UNION ALL SELECT CASE WHEN ra.privs_raw LIKE '%X%' THEN 'EXECUTE' END
                        ) AS priv_subquery WHERE priv_subquery.privilege IS NOT NULL ORDER BY priv_subquery.privilege
                    ), ',')
                END AS privilege,
                ir.inherited_role,
                'default_acl'::TEXT AS source
            FROM raw_acls ra
            LEFT JOIN inherited_roles ir ON ra.grantee = ir.role_name
        )

        -- Combine all privilege types and filter by p_role if provided
        SELECT sc.object_scope, sc.grantee, sc.privilege, sc.inherited_role, sc.source FROM schema_create sc WHERE p_role = '' OR sc.grantee = p_role
        UNION ALL
        SELECT su.object_scope, su.grantee, su.privilege, su.inherited_role, su.source FROM schema_usage su WHERE p_role = '' OR su.grantee = p_role
        UNION ALL
        SELECT db.object_scope, db.grantee, db.privilege, db.inherited_role, db.source FROM db_privs db WHERE p_role = '' OR db.grantee = p_role
        UNION ALL
        SELECT ea.object_scope, ea.grantee, ea.privilege, ea.inherited_role, ea.source FROM expanded_acls ea WHERE p_role = '' OR ea.grantee = p_role
        ORDER BY grantee, object_scope, privilege;
    END;
    $_$;


ALTER FUNCTION dba.getprivileges(p_role text) OWNER TO dba_team;



-- Name: SCHEMA dba; Type: ACL; Schema: -; Owner: dba_team


GRANT USAGE ON SCHEMA dba TO db_datareader;
GRANT USAGE ON SCHEMA dba TO db_datawriter;
GRANT USAGE ON SCHEMA dba TO db_ddladmin_c;


--
-- Name: SCHEMA public; Type: ACL; Schema: -; Owner: pg_database_owner
--

GRANT USAGE ON SCHEMA public TO db_ddladmin_c;
GRANT USAGE ON SCHEMA public TO db_datareader;
GRANT USAGE ON SCHEMA public TO db_datawriter;
GRANT ALL ON SCHEMA public TO db_ddladmin;


--
-- Name: FUNCTION getprivileges(p_role text); Type: ACL; Schema: dba; Owner: dba_team
--

GRANT ALL ON FUNCTION dba.getprivileges(p_role text) TO db_datareader;
GRANT ALL ON FUNCTION dba.getprivileges(p_role text) TO db_datawriter;
GRANT ALL ON FUNCTION dba.getprivileges(p_role text) TO db_ddladmin;
GRANT ALL ON FUNCTION dba.getprivileges(p_role text) TO db_ddladmin_c;


--
-- Name: DEFAULT PRIVILEGES FOR TABLES; Type: DEFAULT ACL; Schema: dba; Owner: dba_team
--

ALTER DEFAULT PRIVILEGES FOR ROLE dba_team IN SCHEMA dba GRANT SELECT,INSERT,DELETE,UPDATE ON TABLES TO db_ddladmin;
ALTER DEFAULT PRIVILEGES FOR ROLE dba_team IN SCHEMA dba GRANT SELECT,INSERT,DELETE,UPDATE ON TABLES TO db_datawriter;
ALTER DEFAULT PRIVILEGES FOR ROLE dba_team IN SCHEMA dba GRANT SELECT ON TABLES TO db_datareader;


--
-- Name: DEFAULT PRIVILEGES FOR TABLES; Type: DEFAULT ACL; Schema: public; Owner: dba_team
--

ALTER DEFAULT PRIVILEGES FOR ROLE dba_team IN SCHEMA public GRANT ALL ON TABLES TO db_ddladmin;
ALTER DEFAULT PRIVILEGES FOR ROLE dba_team IN SCHEMA public GRANT ALL ON TABLES TO db_ddladmin_c;
ALTER DEFAULT PRIVILEGES FOR ROLE dba_team IN SCHEMA public GRANT SELECT,INSERT,DELETE,UPDATE ON TABLES TO db_datawriter;
ALTER DEFAULT PRIVILEGES FOR ROLE dba_team IN SCHEMA public GRANT SELECT ON TABLES TO db_datareader;


--
-- PostgreSQL database dump complete
--UPDATE pg_database SET datistemplate = true WHERE datname = :'modeldbname';

-- Optional: restrict access
 REVOKE CONNECT ON DATABASE :modeldbname FROM PUBLIC;
-- GRANT CONNECT ON DATABASE :modeldbname TO :dbaname;

-- ‚úÖ model template created successfully--- END FAILED SCRIPT ---
üìÑ [DBA] /c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/1 initial/role_creations.sql
üîó Running: psql -U "jrussell" -h "psqltstawrd01.clm0vrvchewi.us-east-2.rds.amazonaws.com" -p "5432" -d DBA -f "/c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/1 initial/role_creations.sql"
psql: error: connection to server at "psqltstawrd01.clm0vrvchewi.us-east-2.rds.amazonaws.com" (172.31.26.43), port 5432 failed: FATAL:  database "DBA" does not exist
‚ùå ERROR running /c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/1 initial/role_creations.sql against DBA
--- FAILED COMMAND ---
psql -U "jrussell" -h "psqltstawrd01.clm0vrvchewi.us-east-2.rds.amazonaws.com" -p "5432" -d DBA -f "/c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/1 initial/role_creations.sql"
--- BEGIN FAILED SCRIPT: /c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/1 initial/role_creations.sql ---
set role dbadmin;

-- Create role db_ddladmin if it doesn't exist
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_roles WHERE rolname = 'db_ddladmin') THEN
        CREATE ROLE db_ddladmin 
        WITH NOSUPERUSER NOCREATEDB NOCREATEROLE NOINHERIT NOLOGIN NOREPLICATION NOBYPASSRLS CONNECTION LIMIT -1;
        RAISE NOTICE 'Role "db_ddladmin" created.';
    ELSE
        RAISE NOTICE 'Role "db_ddladmin" already exists.';
    END IF;
END
$$;



-- Create role db_ddladmin if it doesn't exist
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_roles WHERE rolname = 'db_ddladmin_c') THEN
        CREATE ROLE db_ddladmin_c 
        WITH NOSUPERUSER NOCREATEDB NOCREATEROLE NOINHERIT NOLOGIN NOREPLICATION NOBYPASSRLS CONNECTION LIMIT -1;
        RAISE NOTICE 'Role "db_ddladmin_c" created.';
    ELSE
        RAISE NOTICE 'Role "db_ddladmin_c" already exists.';
    END IF;
END
$$;

-- Create role db_datawriter if it doesn't exist
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_roles WHERE rolname = 'db_datawriter') THEN
        CREATE ROLE db_datawriter 
        WITH NOSUPERUSER NOCREATEDB NOCREATEROLE NOINHERIT NOLOGIN NOREPLICATION NOBYPASSRLS CONNECTION LIMIT -1;
        RAISE NOTICE 'Role "db_datawriter" created.';
    ELSE
        RAISE NOTICE 'Role "db_datawriter" already exists.';
    END IF;
END
$$;

-- Create role db_datareader if it doesn't exist
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_roles WHERE rolname = 'db_datareader') THEN
        CREATE ROLE db_datareader 
        WITH NOSUPERUSER NOCREATEDB NOCREATEROLE NOINHERIT NOLOGIN NOREPLICATION NOBYPASSRLS CONNECTION LIMIT -1;
        RAISE NOTICE 'Role "db_datareader" created.';
    ELSE
        RAISE NOTICE 'Role "db_datareader" already exists.';
    END IF;
END
$$;

-- Create role dba_team if it doesn't exist
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_roles WHERE rolname = 'dba_team') THEN
        CREATE ROLE dba_team 
        WITH NOSUPERUSER NOCREATEDB NOCREATEROLE INHERIT NOLOGIN NOREPLICATION NOBYPASSRLS CONNECTION LIMIT -1;
          GRANT dbadmin TO dba_team;
		RAISE NOTICE 'Role "dba_team" created.';
    ELSE
        RAISE NOTICE 'Role "dba_team" already exists.';
    END IF;
END
$$;


-- Grant db_datawriter to dba_team if both roles exist and grant not already applied
DO $$
BEGIN
    IF EXISTS (SELECT 1 FROM pg_roles WHERE rolname = 'db_datawriter')
       AND EXISTS (SELECT 1 FROM pg_roles WHERE rolname = 'dba_team')
       AND NOT EXISTS (
           SELECT 1 
           FROM pg_auth_members 
           WHERE roleid = (SELECT oid FROM pg_roles WHERE rolname = 'db_datawriter')
             AND member = (SELECT oid FROM pg_roles WHERE rolname = 'dba_team')
       ) THEN
        GRANT db_datawriter TO dba_team;
        RAISE NOTICE 'Granted db_datawriter to dba_team.';
    ELSE
        RAISE NOTICE 'Grant db_datawriter to dba_team already exists or roles missing.';
    END IF;
END
$$;

-- Grant db_ddladmin to dba_team
DO $$
BEGIN
    IF EXISTS (SELECT 1 FROM pg_roles WHERE rolname = 'db_ddladmin')
       AND EXISTS (SELECT 1 FROM pg_roles WHERE rolname = 'dba_team')
       AND NOT EXISTS (
           SELECT 1 
           FROM pg_auth_members 
           WHERE roleid = (SELECT oid FROM pg_roles WHERE rolname = 'db_ddladmin')
             AND member = (SELECT oid FROM pg_roles WHERE rolname = 'dba_team')
       ) THEN
        GRANT db_ddladmin TO dba_team;
        RAISE NOTICE 'Granted db_ddladmin to dba_team.';
    ELSE
        RAISE NOTICE 'Grant db_ddladmin to dba_team already exists or roles missing.';
    END IF;
END
$$;

-- Grant db_datareader to dba_team
DO $$
BEGIN
    IF EXISTS (SELECT 1 FROM pg_roles WHERE rolname = 'db_datareader')
       AND EXISTS (SELECT 1 FROM pg_roles WHERE rolname = 'dba_team')
       AND NOT EXISTS (
           SELECT 1 
           FROM pg_auth_members 
           WHERE roleid = (SELECT oid FROM pg_roles WHERE rolname = 'db_datareader')
             AND member = (SELECT oid FROM pg_roles WHERE rolname = 'dba_team')
       ) THEN
        GRANT db_datareader TO dba_team;
        RAISE NOTICE 'Granted db_datareader to dba_team.';
    ELSE
        RAISE NOTICE 'Grant db_datareader to dba_team already exists or roles missing.';
    END IF;
END
$$;


-- Grant db_ddladmin to dba_team
DO $$
BEGIN
    IF EXISTS (SELECT 1 FROM pg_roles WHERE rolname = 'db_ddladmin_c')
       AND EXISTS (SELECT 1 FROM pg_roles WHERE rolname = 'dba_team')
       AND NOT EXISTS (
           SELECT 1 
           FROM pg_auth_members 
           WHERE roleid = (SELECT oid FROM pg_roles WHERE rolname = 'db_ddladmin_c')
             AND member = (SELECT oid FROM pg_roles WHERE rolname = 'dba_team')
       ) THEN
        GRANT db_ddladmin_c TO dba_team;
        RAISE NOTICE 'Granted db_ddladmin_c to dba_team.';
    ELSE
        RAISE NOTICE 'Grant db_ddladmin_c to dba_team already exists or roles missing.';
    END IF;
END
$$;--- END FAILED SCRIPT ---
üìÑ [DBA] /c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/2 deploy/deploy.DropSchemaWithCleanup.sql
üîó Running: psql -U "jrussell" -h "psqltstawrd01.clm0vrvchewi.us-east-2.rds.amazonaws.com" -p "5432" -d DBA -f "/c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/2 deploy/deploy.DropSchemaWithCleanup.sql"
psql: error: connection to server at "psqltstawrd01.clm0vrvchewi.us-east-2.rds.amazonaws.com" (172.31.26.43), port 5432 failed: FATAL:  database "DBA" does not exist
‚ùå ERROR running /c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/2 deploy/deploy.DropSchemaWithCleanup.sql against DBA
--- FAILED COMMAND ---
psql -U "jrussell" -h "psqltstawrd01.clm0vrvchewi.us-east-2.rds.amazonaws.com" -p "5432" -d DBA -f "/c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/2 deploy/deploy.DropSchemaWithCleanup.sql"
--- BEGIN FAILED SCRIPT: /c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/2 deploy/deploy.DropSchemaWithCleanup.sql ---
set role dba_team; 

CREATE OR REPLACE FUNCTION deploy.DropSchemaWithCleanup(
    p_schema_name TEXT,
    p_execute_flag BOOLEAN DEFAULT FALSE,
    p_cascade BOOLEAN DEFAULT FALSE
)
RETURNS TEXT
LANGUAGE plpgsql
AS $$
DECLARE
    v_exists BOOLEAN;
    v_sql TEXT;
    v_log_status TEXT;
BEGIN
    SELECT EXISTS (
        SELECT 1 FROM information_schema.schemata WHERE schema_name = p_schema_name
    ) INTO v_exists;

    IF NOT v_exists THEN
        v_log_status := 'NOT_FOUND';
        RAISE NOTICE 'Schema "%" does not exist.', p_schema_name;

        INSERT INTO dba.object_log_history (
            action_type, target_entity, associated_entity, status, sql_command, message
        ) VALUES (
            'DROP_SCHEMA',
            p_schema_name,
            NULL,
            v_log_status,
            NULL,
           'No schema dropped ‚Äî not found.'       -- if your editor truly supports UTF-8
        );

        RETURN format('Schema "%s" does not exist.', p_schema_name);
    END IF;

    v_sql := format('DROP SCHEMA %I %s',
        p_schema_name,
        CASE WHEN p_cascade THEN 'CASCADE' ELSE 'RESTRICT' END
    );

    RAISE NOTICE '[DRY-RUN] Would drop schema: %', p_schema_name;

    IF p_execute_flag THEN
        EXECUTE v_sql;
        v_log_status := 'EXECUTED';
        RAISE NOTICE 'Schema "%" dropped.', p_schema_name;
    ELSE
        v_log_status := 'DRY_RUN';
    END IF;

    INSERT INTO dba.object_log_history (
        action_type, target_entity, associated_entity, status, sql_command, message
    ) VALUES (
        'DROP_SCHEMA',
        p_schema_name,
        NULL,
        v_log_status,
        v_sql,
        'Schema drop processed.'
    );

    RETURN format('Schema "%s" drop %s.', p_schema_name, v_log_status);
END;
$$;

ALTER FUNCTION deploy.DropSchemaWithCleanup(TEXT, BOOLEAN, BOOLEAN)
OWNER TO dba_team;
--- END FAILED SCRIPT ---
üìÑ [DBA] /c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/2 deploy/deploy.SetAccountRevoke.sql
üîó Running: psql -U "jrussell" -h "psqltstawrd01.clm0vrvchewi.us-east-2.rds.amazonaws.com" -p "5432" -d DBA -f "/c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/2 deploy/deploy.SetAccountRevoke.sql"
psql: error: connection to server at "psqltstawrd01.clm0vrvchewi.us-east-2.rds.amazonaws.com" (172.31.26.43), port 5432 failed: FATAL:  database "DBA" does not exist
‚ùå ERROR running /c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/2 deploy/deploy.SetAccountRevoke.sql against DBA
--- FAILED COMMAND ---
psql -U "jrussell" -h "psqltstawrd01.clm0vrvchewi.us-east-2.rds.amazonaws.com" -p "5432" -d DBA -f "/c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/2 deploy/deploy.SetAccountRevoke.sql"
--- BEGIN FAILED SCRIPT: /c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/2 deploy/deploy.SetAccountRevoke.sql ---
-- FUNCTION: deploy.setaccountrevoke(text[], text[], text[], text[], text[], boolean, boolean)

-- DROP FUNCTION IF EXISTS deploy.setaccountrevoke(text[], text[], text[], text[], text[], boolean, boolean);
set role dba_team; 


CREATE OR REPLACE FUNCTION deploy.SetAccountRevoke(
    p_usernames TEXT[] DEFAULT NULL,
    p_role_names TEXT[] DEFAULT NULL,
    p_schemas TEXT[] DEFAULT NULL,
    p_inherit_roles TEXT[] DEFAULT NULL,
    p_object_roles TEXT[] DEFAULT NULL,
    p_execute_flag BOOLEAN DEFAULT FALSE,
    p_verbose_flag BOOLEAN DEFAULT FALSE
)
    RETURNS text
    LANGUAGE plpgsql
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $$
DECLARE
    v_result TEXT := '';
BEGIN
    -- Step 1: Revoke user inheritance (GRANT role TO user)
    IF p_usernames IS NOT NULL AND p_inherit_roles IS NOT NULL THEN
        v_result := v_result || deploy.SetRevokeUser(
            p_usernames := p_usernames,
            p_inherit_roles := p_inherit_roles,
            p_execute_flag := p_execute_flag
        ) || E'\n';
    END IF;

    -- Step 2: Drop users
    IF p_usernames IS NOT NULL THEN
        v_result := v_result || deploy.SetRevokeUser(
            p_usernames := p_usernames,
            p_execute_flag := p_execute_flag
        ) || E'\n';
    END IF;

    -- Step 3: Revoke object-level permissions for roles
    IF p_object_roles IS NOT NULL AND p_schemas IS NOT NULL THEN
        v_result := v_result || deploy.SetRevokeRolePermissions(
            p_roles := p_object_roles,
            p_schemas := p_schemas,
            p_execute_flag := p_execute_flag
        ) || E'\n';
    END IF;

    -- Step 4: Drop roles
    IF p_role_names IS NOT NULL THEN
        v_result := v_result || deploy.SetRoleRevoke(
            p_roles := p_role_names,
            p_execute_flag := p_execute_flag
        ) || E'\n';
    END IF;

    RETURN v_result;
END;
$$;

ALTER FUNCTION deploy.SetAccountRevoke(
    TEXT[], TEXT[], TEXT[], TEXT[], TEXT[], BOOLEAN, BOOLEAN
) OWNER TO dba_team;
--- END FAILED SCRIPT ---
üìÑ [DBA] /c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/2 deploy/deploy.SetAccountSetup.sql
üîó Running: psql -U "jrussell" -h "psqltstawrd01.clm0vrvchewi.us-east-2.rds.amazonaws.com" -p "5432" -d DBA -f "/c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/2 deploy/deploy.SetAccountSetup.sql"
psql: error: connection to server at "psqltstawrd01.clm0vrvchewi.us-east-2.rds.amazonaws.com" (172.31.26.43), port 5432 failed: FATAL:  database "DBA" does not exist
‚ùå ERROR running /c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/2 deploy/deploy.SetAccountSetup.sql against DBA
--- FAILED COMMAND ---
psql -U "jrussell" -h "psqltstawrd01.clm0vrvchewi.us-east-2.rds.amazonaws.com" -p "5432" -d DBA -f "/c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/2 deploy/deploy.SetAccountSetup.sql"
--- BEGIN FAILED SCRIPT: /c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/2 deploy/deploy.SetAccountSetup.sql ---
-- Create or replace the parent function to handle full account setup

set role dba_team; 


CREATE OR REPLACE FUNCTION deploy.SetAccountSetup(
    p_role_names TEXT[] DEFAULT NULL,
    p_usernames TEXT[] DEFAULT NULL,
    p_user_password TEXT DEFAULT NULL,
    p_user_inherit_roles TEXT[] DEFAULT NULL,
    p_apply_schema_privs_to_roles TEXT[] DEFAULT NULL,
    p_table_privileges TEXT[] DEFAULT NULL,
    p_function_privileges TEXT[] DEFAULT NULL,
    p_apply_to_existing_tables BOOLEAN DEFAULT FALSE,
    p_set_default_for_future_tables BOOLEAN DEFAULT FALSE,
    p_set_default_for_future_functions BOOLEAN DEFAULT FALSE,
    p_revoke_all_first BOOLEAN DEFAULT FALSE,
    p_execute_flag BOOLEAN DEFAULT FALSE
)
RETURNS TEXT
LANGUAGE plpgsql
AS $$
/*
-- ===============================
-- EXAMPLE 1: Only Create Roles
-- ===============================
SELECT deploy.SetAccountSetup(
    p_role_names := ARRAY['app_reader', 'app_writer']
);

-- ===============================
-- EXAMPLE 2: Only Create Users
-- ===============================
SELECT deploy.SetAccountSetup(
    p_usernames := ARRAY['johndoe', 'janedoe'],
    p_user_password := 'SuperSecure123!',
    p_user_inherit_roles := ARRAY['app_reader']
);

-- ===============================
-- EXAMPLE 3: Only Apply Permissions
-- ===============================
SELECT deploy.SetAccountSetup(
    p_apply_schema_privs_to_roles := ARRAY['app_reader'],
    p_table_privileges := ARRAY['SELECT'],
    p_function_privileges := ARRAY['EXECUTE'],
    p_apply_to_existing_tables := TRUE,
    p_set_default_for_future_tables := TRUE,
    p_set_default_for_future_functions := TRUE
);

-- ===============================
-- EXAMPLE 4: Create Roles + Apply Permissions (no user)
-- ===============================
SELECT deploy.SetAccountSetup(
    p_role_names := ARRAY['app_reader'],
    p_user_inherit_roles := ARRAY['base_role'],
    p_apply_schema_privs_to_roles := ARRAY['app_reader'],
    p_table_privileges := ARRAY['SELECT'],
    p_execute_flag := TRUE
);

-- ===============================
-- EXAMPLE 5: Create Roles + Users (no permissions)
-- ===============================
SELECT deploy.SetAccountSetup(
    p_role_names := ARRAY['app_writer'],
    p_usernames := ARRAY['service_account'],
    p_user_password := 'pw123!',
    p_user_inherit_roles := ARRAY['app_writer'],
    p_execute_flag := TRUE
);

-- ===============================
-- EXAMPLE 6: Full Setup (Roles + Permissions + Users)
-- ===============================
SELECT deploy.SetAccountSetup(
    p_role_names := ARRAY['db_datareader'],
    p_usernames := ARRAY['alice'],
    p_user_password := 'alice123!',
    p_user_inherit_roles := ARRAY['db_datareader'],
    p_apply_schema_privs_to_roles := ARRAY['db_datareader'],
    p_table_privileges := ARRAY['SELECT'],
    p_function_privileges := ARRAY['EXECUTE'],
    p_apply_to_existing_tables := TRUE,
    p_set_default_for_future_tables := TRUE,
    p_execute_flag := TRUE
);

-- ===============================
-- EXAMPLE 7: Dry Run Preview (Any of the above)
-- ===============================
SELECT deploy.SetAccountSetup(
    p_usernames := ARRAY['dryrun_user'],
    p_user_password := 'notused',
    p_user_inherit_roles := ARRAY['no_inherit'],
    p_execute_flag := FALSE -- DRY RUN!
);
*/
DECLARE
    v_result TEXT := '';
BEGIN
    -- Step 1: Role Creation
    IF p_role_names IS NOT NULL AND array_length(p_role_names, 1) > 0 THEN
        v_result := v_result || deploy.SetRoleCreation(
            p_role_names := p_role_names,
            p_user_inherit_roles := p_user_inherit_roles,
            p_execute_flag := p_execute_flag
        ) || E'\n';
    END IF;

    -- Step 2: Grant Permissions
    IF p_apply_schema_privs_to_roles IS NOT NULL AND (p_table_privileges IS NOT NULL OR p_function_privileges IS NOT NULL) THEN
        v_result := v_result || deploy.SetRolePermissions(
            p_apply_schema_privs_to_roles := p_apply_schema_privs_to_roles,
            p_table_privileges := p_table_privileges,
            p_function_privileges := p_function_privileges,
            p_apply_to_existing_tables := p_apply_to_existing_tables,
            p_set_default_for_future_tables := p_set_default_for_future_tables,
            p_set_default_for_future_functions := p_set_default_for_future_functions,
            p_revoke_all_first := p_revoke_all_first,
            p_execute_flag := p_execute_flag
        ) || E'\n';
    END IF;

    -- Step 3: Create Users
    IF p_usernames IS NOT NULL AND array_length(p_usernames, 1) > 0 THEN
        v_result := v_result || deploy.SetCreateUser(
            p_usernames := p_usernames,
            p_user_password := p_user_password,
            p_user_inherit_roles := p_user_inherit_roles,
            p_execute_flag := p_execute_flag
        ) || E'\n';
    END IF;

    RETURN v_result;
END;
$$;
--- END FAILED SCRIPT ---
üìÑ [DBA] /c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/2 deploy/deploy.SetCreateUser.sql
üîó Running: psql -U "jrussell" -h "psqltstawrd01.clm0vrvchewi.us-east-2.rds.amazonaws.com" -p "5432" -d DBA -f "/c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/2 deploy/deploy.SetCreateUser.sql"
psql: error: connection to server at "psqltstawrd01.clm0vrvchewi.us-east-2.rds.amazonaws.com" (172.31.26.43), port 5432 failed: FATAL:  database "DBA" does not exist
‚ùå ERROR running /c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/2 deploy/deploy.SetCreateUser.sql against DBA
--- FAILED COMMAND ---
psql -U "jrussell" -h "psqltstawrd01.clm0vrvchewi.us-east-2.rds.amazonaws.com" -p "5432" -d DBA -f "/c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/2 deploy/deploy.SetCreateUser.sql"
--- BEGIN FAILED SCRIPT: /c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/2 deploy/deploy.SetCreateUser.sql ---
-- ================================================================
-- FUNCTION: deploy.SetCreateUser()
-- DESCRIPTION: Creates users, assigns roles, logs actions securely
-- OWNER: dba_team
-- ==============================================================

-- DROP FUNCTION IF EXISTS deploy.setcreateuser(text[], text, text[], boolean);
set role dba_team; 


CREATE OR REPLACE FUNCTION deploy.setcreateuser(
    p_usernames TEXT[],
    p_user_password TEXT DEFAULT NULL,
    p_user_inherit_roles TEXT[] DEFAULT NULL,
    p_execute_flag BOOLEAN DEFAULT FALSE
)
RETURNS TEXT
LANGUAGE plpgsql
COST 100
VOLATILE PARALLEL UNSAFE
AS $$
DECLARE
    v_entity_exists BOOLEAN;
    v_is_member BOOLEAN;
    v_sql_command TEXT;
    v_sql_command_real TEXT;
    v_log_status TEXT;
    v_return_message TEXT := '';
    v_current_user_name TEXT;
    v_current_inherit_role TEXT;
    v_generated_password TEXT;
    password_mask_pattern TEXT := E'WITH (?:LOGIN\s+)?PASSWORD\s+''[^'']*''';
    masked_password_string TEXT := 'WITH LOGIN PASSWORD ''xxxxxxxxxxxxxx''';
BEGIN
    IF p_usernames IS NOT NULL AND array_length(p_usernames, 1) > 0 THEN
        FOREACH v_current_user_name IN ARRAY p_usernames LOOP
            SELECT EXISTS (SELECT 1 FROM pg_roles WHERE rolname = v_current_user_name)
            INTO v_entity_exists;

            v_generated_password := p_user_password;
            IF v_generated_password IS NULL THEN
                v_generated_password := v_current_user_name || 'Pass123!';
                RAISE NOTICE 'Default password assigned for user "%".', v_current_user_name;
            END IF;

            IF NOT v_entity_exists THEN
                v_sql_command := format('CREATE ROLE %I WITH LOGIN PASSWORD ''xxxxxxxxxxxxxx''', v_current_user_name);
                v_sql_command_real := format('CREATE ROLE %I WITH LOGIN PASSWORD %L', v_current_user_name, v_generated_password);
                RAISE NOTICE '[DRY-RUN] Would create user: "%"', v_current_user_name;

                IF p_execute_flag THEN
                    EXECUTE v_sql_command_real;
                    v_log_status := 'EXECUTED';
                    RAISE NOTICE 'User "%s" created.', v_current_user_name;
                ELSE
                    v_log_status := 'DRY_RUN';
                END IF;

                INSERT INTO info.account_log_history (
                    action_type,
                    target_entity,
                    associated_entity,
                    status,
                    sql_command,
                    message
                ) VALUES (
                    'CREATE_USER',
                    v_current_user_name,
                    NULL,
                    v_log_status,
                    v_sql_command,
                    'User creation attempted.' || CASE WHEN v_log_status = 'EXECUTED' THEN ' Password set (not logged).' ELSE '' END
                );

                v_return_message := v_return_message || format('User "%s" created. ', v_current_user_name);
            ELSE
                v_log_status := 'ALREADY_EXISTS';
                INSERT INTO info.account_log_history (
                    action_type,
                    target_entity,
                    associated_entity,
                    status,
                    sql_command,
                    message
                ) VALUES (
                    'CREATE_USER',
                    v_current_user_name,
                    NULL,
                    v_log_status,
                    NULL,
                    'User already existed, no action taken.'
                );
            END IF;

            IF p_user_inherit_roles IS NOT NULL AND array_length(p_user_inherit_roles, 1) > 0 THEN
                FOREACH v_current_inherit_role IN ARRAY p_user_inherit_roles LOOP
                    SELECT EXISTS (SELECT 1 FROM pg_roles WHERE rolname = v_current_inherit_role)
                    INTO v_entity_exists;

                    IF NOT v_entity_exists THEN
                        RAISE WARNING 'Inheritance role "%" for user "%" does not exist. Skipping grant.', v_current_inherit_role, v_current_user_name;
                        INSERT INTO info.account_log_history (
                            action_type,
                            target_entity,
                            associated_entity,
                            status,
                            sql_command,
                            message
                        ) VALUES (
                            'GRANT_MEMBERSHIP',
                            v_current_user_name,
                            v_current_inherit_role,
                            'SKIPPED',
                            NULL,
                            format('Inheritance role "%s" does not exist for user "%s". Grant skipped.', v_current_inherit_role, v_current_user_name)
                        );
                        CONTINUE;
                    END IF;

                    SELECT EXISTS (
                        SELECT 1
                        FROM pg_auth_members m
                        JOIN pg_roles r1 ON m.roleid = r1.oid
                        JOIN pg_roles r2 ON m.member = r2.oid
                        WHERE r1.rolname = v_current_inherit_role
                          AND r2.rolname = v_current_user_name
                    ) INTO v_is_member;

                    IF NOT v_is_member THEN
                        v_sql_command := format('GRANT %I TO %I', v_current_inherit_role, v_current_user_name);
                        IF p_execute_flag THEN
                            EXECUTE v_sql_command;
                            v_log_status := 'EXECUTED';
                        ELSE
                            v_log_status := 'DRY_RUN';
                        END IF;

                        INSERT INTO info.account_log_history (
                            action_type,
                            target_entity,
                            associated_entity,
                            status,
                            sql_command,
                            message
                        ) VALUES (
                            'GRANT_MEMBERSHIP',
                            v_current_user_name,
                            v_current_inherit_role,
                            v_log_status,
                            v_sql_command,
                            'Granted inheritance role to user.'
                        );
                    END IF;
                END LOOP;
            END IF;
        END LOOP;
    END IF;

    RETURN v_return_message;
END;
$$;

ALTER FUNCTION deploy.setcreateuser(text[], text, text[], boolean)
    OWNER TO dba_team;
--- END FAILED SCRIPT ---
üìÑ [DBA] /c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/2 deploy/deploy.SetRevokeRolePermissions.sql
üîó Running: psql -U "jrussell" -h "psqltstawrd01.clm0vrvchewi.us-east-2.rds.amazonaws.com" -p "5432" -d DBA -f "/c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/2 deploy/deploy.SetRevokeRolePermissions.sql"
psql: error: connection to server at "psqltstawrd01.clm0vrvchewi.us-east-2.rds.amazonaws.com" (172.31.26.43), port 5432 failed: FATAL:  database "DBA" does not exist
‚ùå ERROR running /c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/2 deploy/deploy.SetRevokeRolePermissions.sql against DBA
--- FAILED COMMAND ---
psql -U "jrussell" -h "psqltstawrd01.clm0vrvchewi.us-east-2.rds.amazonaws.com" -p "5432" -d DBA -f "/c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/2 deploy/deploy.SetRevokeRolePermissions.sql"
--- BEGIN FAILED SCRIPT: /c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/2 deploy/deploy.SetRevokeRolePermissions.sql ---
-- ===============================================
-- FUNCTION: deploy.SetRevokeRolePermissions()
-- DESCRIPTION: Revokes table/function privileges, removes users from roles,
--              optionally drops roles, and logs actions.
-- OWNER: dba_team
-- ===============================================

set role dba_team; 


CREATE OR REPLACE FUNCTION deploy.SetRevokeRolePermissions(
    p_role_names TEXT[],
    p_users_to_remove TEXT[] DEFAULT NULL,
    p_schema_targets TEXT[] DEFAULT NULL,
    p_revoke_table_privileges TEXT[] DEFAULT NULL,
    p_revoke_function_privileges TEXT[] DEFAULT NULL,
    p_drop_roles BOOLEAN DEFAULT FALSE,
    p_execute_flag BOOLEAN DEFAULT FALSE
)
RETURNS TEXT
LANGUAGE plpgsql
COST 100
VOLATILE PARALLEL UNSAFE
AS $$
DECLARE
    v_role TEXT;
    v_user TEXT;
    v_schema TEXT;
    v_priv TEXT;
    v_sql TEXT;
    v_log TEXT := '';
    v_log_status TEXT;
BEGIN
    FOREACH v_role IN ARRAY p_role_names LOOP

        -- Remove role from users
        IF p_users_to_remove IS NOT NULL THEN
            FOREACH v_user IN ARRAY p_users_to_remove LOOP
                v_sql := format('REVOKE %I FROM %I;', v_role, v_user);
                IF p_execute_flag THEN EXECUTE v_sql; END IF;
                v_log_status := CASE WHEN p_execute_flag THEN 'EXECUTED' ELSE 'DRY_RUN' END;
                INSERT INTO info.account_log_history (action_type, target_entity, associated_entity, status, sql_command, message)
                VALUES ('REVOKE_ROLE', v_user, v_role, v_log_status, v_sql, 'Revoked role from user');
                v_log := v_log || v_sql || E'\n';
            END LOOP;
        END IF;

        --Revoke schema/table/function privileges
        IF p_schema_targets IS NOT NULL THEN
            FOREACH v_schema IN ARRAY p_schema_targets LOOP

                -- Revoke TABLE privileges
                IF p_revoke_table_privileges IS NOT NULL THEN
                    FOREACH v_priv IN ARRAY p_revoke_table_privileges LOOP
                        v_sql := format('REVOKE %s ON ALL TABLES IN SCHEMA %I FROM %I;', v_priv, v_schema, v_role);
                        IF p_execute_flag THEN EXECUTE v_sql; END IF;
                        v_log_status := CASE WHEN p_execute_flag THEN 'EXECUTED' ELSE 'DRY_RUN' END;
                        INSERT INTO info.account_log_history (action_type, target_entity, associated_entity, status, sql_command, message)
                        VALUES ('REVOKE_TABLES', v_role, v_schema, v_log_status, v_sql, 'Revoked table privilege');
                        v_log := v_log || v_sql || E'\n';
                    END LOOP;
                END IF;

                -- Revoke FUNCTION privileges
                IF p_revoke_function_privileges IS NOT NULL THEN
                    FOREACH v_priv IN ARRAY p_revoke_function_privileges LOOP
                        v_sql := format('REVOKE %s ON ALL FUNCTIONS IN SCHEMA %I FROM %I;', v_priv, v_schema, v_role);
                        IF p_execute_flag THEN EXECUTE v_sql; END IF;
                        v_log_status := CASE WHEN p_execute_flag THEN 'EXECUTED' ELSE 'DRY_RUN' END;
                        INSERT INTO info.account_log_history (action_type, target_entity, associated_entity, status, sql_command, message)
                        VALUES ('REVOKE_FUNCTIONS', v_role, v_schema, v_log_status, v_sql, 'Revoked function privilege');
                        v_log := v_log || v_sql || E'\n';
                    END LOOP;
                END IF;
            END LOOP;
        END IF;

        -- Drop Role if requested
        IF p_drop_roles THEN
            v_sql := format('DROP ROLE IF EXISTS %I;', v_role);
            IF p_execute_flag THEN EXECUTE v_sql; END IF;
            v_log_status := CASE WHEN p_execute_flag THEN 'EXECUTED' ELSE 'DRY_RUN' END;
            INSERT INTO info.account_log_history (action_type, target_entity, associated_entity, status, sql_command, message)
            VALUES ('DROP_ROLE', v_role, NULL, v_log_status, v_sql, 'Dropped role');
            v_log := v_log || v_sql || E'\n';
        END IF;
		
    END LOOP;
    RETURN v_log;
END;
$$;
ALTER FUNCTION deploy.SetRevokeRolePermissions(
    TEXT[], TEXT[], TEXT[], TEXT[], TEXT[],
    BOOLEAN, BOOLEAN
) OWNER TO dba_team;--- END FAILED SCRIPT ---
üìÑ [DBA] /c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/2 deploy/deploy.SetRevokeUser.sql
üîó Running: psql -U "jrussell" -h "psqltstawrd01.clm0vrvchewi.us-east-2.rds.amazonaws.com" -p "5432" -d DBA -f "/c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/2 deploy/deploy.SetRevokeUser.sql"
psql: error: connection to server at "psqltstawrd01.clm0vrvchewi.us-east-2.rds.amazonaws.com" (172.31.26.43), port 5432 failed: FATAL:  database "DBA" does not exist
‚ùå ERROR running /c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/2 deploy/deploy.SetRevokeUser.sql against DBA
--- FAILED COMMAND ---
psql -U "jrussell" -h "psqltstawrd01.clm0vrvchewi.us-east-2.rds.amazonaws.com" -p "5432" -d DBA -f "/c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/2 deploy/deploy.SetRevokeUser.sql"
--- BEGIN FAILED SCRIPT: /c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/2 deploy/deploy.SetRevokeUser.sql ---
-- FUNCTION: deploy.setrevokeuser(text[], text[], boolean, boolean)

-- DROP FUNCTION IF EXISTS deploy.setrevokeuser(text[], text[], boolean, boolean);
set role dba_team; 


CREATE OR REPLACE FUNCTION deploy.SetRevokeUser(
    p_usernames TEXT[],
    p_inherit_roles TEXT[] DEFAULT NULL,
    p_execute_flag BOOLEAN DEFAULT FALSE,
    p_drop_user BOOLEAN DEFAULT FALSE
)
RETURNS TEXT
LANGUAGE plpgsql
/*


SELECT deploy.SetRevokeUser(
    p_usernames     := ARRAY['superman'],
    p_inherit_roles := ARRAY['db_datareader'],
    p_execute_flag  := TRUE,
    p_drop_user     := TRUE
);

/*
============================================================================
üß™ DRY-RUN ONLY ‚Äî TEST REVOKING ROLES (DON'T EXECUTE)
============================================================================
*/
SELECT deploy.SetRevokeUser(
    p_usernames     := ARRAY['user_qa', 'user_test'],
    p_inherit_roles := ARRAY['db_viewer', 'db_readonly'],
    p_execute_flag  := FALSE,
    p_drop_user     := FALSE
);

/*
============================================================================
ü™ì REVOKE ROLES FROM USERS ‚Äî THEN DROP USERS (default behavior)
============================================================================
*/
SELECT deploy.SetRevokeUser(
    p_usernames     := ARRAY['user_temp1', 'user_temp2'],
    p_inherit_roles := ARRAY['db_datareader', 'db_function_exec'],
    p_execute_flag  := TRUE
    -- p_drop_user is TRUE by default
);

/*
============================================================================
üõë REVOKE ROLES ONLY ‚Äî DO NOT DROP USERS
============================================================================
*/
SELECT deploy.SetRevokeUser(
    p_usernames     := ARRAY['jrussell'],
    p_inherit_roles := ARRAY['db_datareader'],
    p_execute_flag  := TRUE,
    p_drop_user     := FALSE
);

/*
============================================================================
üî• DROP USERS WITHOUT REVOKING ANYTHING
============================================================================
*/
SELECT deploy.SetRevokeUser(
    p_usernames     := ARRAY['old_admin1', 'retired_user'],
    p_execute_flag  := TRUE,
    p_drop_user     := TRUE
);

/*
============================================================================
üëÄ DRY-RUN FULL DESTRUCTION ‚Äî SEE EVERYTHING THAT WOULD HAPPEN
============================================================================
*/
SELECT deploy.SetRevokeUser(
    p_usernames     := ARRAY['intern_doomed'],
    p_inherit_roles := ARRAY['db_temp'],
    p_execute_flag  := FALSE,
    p_drop_user     := TRUE
);

/*
============================================================================
üßæ BONUS: Inside a Batch Job or Admin Script
============================================================================
*/
DO $$
BEGIN
    PERFORM deploy.SetRevokeUser(
        p_usernames     := ARRAY['app_bot1', 'app_bot2'],
        p_inherit_roles := ARRAY['db_execute_only'],
        p_execute_flag  := TRUE,
        p_drop_user     := TRUE
    );
END
$$;



*/
AS $$
DECLARE
    v_user TEXT;
    v_role TEXT;
    v_sql TEXT;
    v_log_status TEXT;
    v_result TEXT := '';
BEGIN
    IF p_usernames IS NULL OR array_length(p_usernames, 1) = 0 THEN
        RETURN '[WARN] No usernames provided.';
    END IF;

    -- Revoke inherited roles if provided
    IF p_inherit_roles IS NOT NULL THEN
        FOREACH v_user IN ARRAY p_usernames LOOP
            FOREACH v_role IN ARRAY p_inherit_roles LOOP
                v_sql := format('REVOKE %I FROM %I;', v_role, v_user);

                IF p_execute_flag THEN
                    EXECUTE v_sql;
                    v_log_status := 'EXECUTED';
                ELSE
                    v_log_status := 'DRY_RUN';
                END IF;

                INSERT INTO info.account_log_history (
                    action_type, target_entity, associated_entity, status, sql_command, message
                ) VALUES (
                    'REVOKE_ROLE', v_user, v_role, v_log_status, v_sql,
                    'Revoked role from user.'
                );

                v_result := v_result || format('[%s] %s\n', v_log_status, v_sql);
            END LOOP;
        END LOOP;
    END IF;

    -- Optionally drop users
    IF p_drop_user THEN
        FOREACH v_user IN ARRAY p_usernames LOOP
            v_sql := format('DROP ROLE IF EXISTS %I;', v_user);

            IF p_execute_flag THEN
                EXECUTE v_sql;
                v_log_status := 'EXECUTED';
            ELSE
                v_log_status := 'DRY_RUN';
            END IF;

            INSERT INTO info.account_log_history (
                action_type, target_entity, associated_entity, status, sql_command, message
            ) VALUES (
                'DROP_USER', v_user, NULL, v_log_status, v_sql,
                'Dropped user account.'
            );

            v_result := v_result || format('[%s] %s\n', v_log_status, v_sql);
        END LOOP;
    END IF;

    RETURN v_result;
END;
$$;

ALTER FUNCTION deploy.SetRevokeUser(TEXT[], TEXT[], BOOLEAN, BOOLEAN)
    OWNER TO dba_team;
--- END FAILED SCRIPT ---
üìÑ [DBA] /c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/2 deploy/deploy.SetRolePermissions.sql
üîó Running: psql -U "jrussell" -h "psqltstawrd01.clm0vrvchewi.us-east-2.rds.amazonaws.com" -p "5432" -d DBA -f "/c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/2 deploy/deploy.SetRolePermissions.sql"
psql: error: connection to server at "psqltstawrd01.clm0vrvchewi.us-east-2.rds.amazonaws.com" (172.31.26.43), port 5432 failed: FATAL:  database "DBA" does not exist
‚ùå ERROR running /c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/2 deploy/deploy.SetRolePermissions.sql against DBA
--- FAILED COMMAND ---
psql -U "jrussell" -h "psqltstawrd01.clm0vrvchewi.us-east-2.rds.amazonaws.com" -p "5432" -d DBA -f "/c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/2 deploy/deploy.SetRolePermissions.sql"
--- BEGIN FAILED SCRIPT: /c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/2 deploy/deploy.SetRolePermissions.sql ---
-- ===============================================
-- FUNCTION: deploy.SetRolePermissions()
-- DESCRIPTION: Creates roles, grants table/function privileges,
--              optionally assigns users to roles, and logs actions.
-- OWNER: dba_team
-- ===============================================
set role dba_team; 

CREATE OR REPLACE FUNCTION deploy.setrolepermissions(
    p_role_names TEXT[],
    p_users_to_assign TEXT[] DEFAULT NULL,
    p_apply_schema_privs_to_roles TEXT[] DEFAULT NULL,
    p_table_privileges TEXT[] DEFAULT NULL,
    p_function_privileges TEXT[] DEFAULT NULL,
    p_apply_to_existing_tables BOOLEAN DEFAULT FALSE,
    p_set_default_for_future_tables BOOLEAN DEFAULT FALSE,
    p_set_default_for_future_functions BOOLEAN DEFAULT FALSE,
    p_revoke_all_first BOOLEAN DEFAULT FALSE,
    p_execute_flag BOOLEAN DEFAULT FALSE
)
RETURNS TEXT
LANGUAGE plpgsql
COST 100
VOLATILE PARALLEL UNSAFE
AS $$
DECLARE
    v_role TEXT;
    v_user TEXT;
    v_schema TEXT;
    v_priv TEXT;
    v_sql TEXT;
    v_log TEXT := '';
    v_exists BOOLEAN;
    v_log_status TEXT;
BEGIN
    FOREACH v_role IN ARRAY p_role_names LOOP
        SELECT EXISTS (SELECT 1 FROM pg_roles WHERE rolname = v_role) INTO v_exists;
        IF NOT v_exists THEN
            v_sql := format('CREATE ROLE %I;', v_role);
            IF p_execute_flag THEN EXECUTE v_sql; END IF;
            v_log_status := CASE WHEN p_execute_flag THEN 'EXECUTED' ELSE 'DRY_RUN' END;
            INSERT INTO info.account_log_history (action_type, target_entity, associated_entity, status, sql_command, message)
            VALUES ('CREATE_ROLE', v_role, NULL, v_log_status, v_sql, 'Role creation');
            v_log := v_log || v_sql || E'\n';
        END IF;

        IF p_users_to_assign IS NOT NULL THEN
            FOREACH v_user IN ARRAY p_users_to_assign LOOP
                v_sql := format('GRANT %I TO %I;', v_role, v_user);
                IF p_execute_flag THEN EXECUTE v_sql; END IF;
                v_log_status := CASE WHEN p_execute_flag THEN 'EXECUTED' ELSE 'DRY_RUN' END;
                INSERT INTO info.account_log_history (action_type, target_entity, associated_entity, status, sql_command, message)
                VALUES ('GRANT_ROLE', v_role, v_user, v_log_status, v_sql, 'Granted role to user');
                v_log := v_log || v_sql || E'\n';
            END LOOP;
        END IF;

        IF p_apply_schema_privs_to_roles IS NOT NULL THEN
            FOREACH v_schema IN ARRAY p_apply_schema_privs_to_roles LOOP
                SELECT EXISTS (
                    SELECT 1
                    FROM information_schema.schemata
                    WHERE schema_name = v_schema
                ) INTO v_exists;

                IF NOT v_exists THEN
                    v_log := v_log || format('-- Skipped schema %I (not found)', v_schema) || E'\n';
                    CONTINUE;
                END IF;

                IF p_revoke_all_first THEN
                    v_sql := format('REVOKE ALL PRIVILEGES ON ALL TABLES IN SCHEMA %I FROM %I;', v_schema, v_role);
                    IF p_execute_flag THEN EXECUTE v_sql; END IF;
                    v_log_status := CASE WHEN p_execute_flag THEN 'EXECUTED' ELSE 'DRY_RUN' END;
                    INSERT INTO info.account_log_history (action_type, target_entity, associated_entity, status, sql_command, message)
                    VALUES ('REVOKE_TABLES', v_role, v_schema, v_log_status, v_sql, 'Revoked existing table privs');
                    v_log := v_log || v_sql || E'\n';
                END IF;

                IF p_apply_to_existing_tables AND p_table_privileges IS NOT NULL THEN
                    FOREACH v_priv IN ARRAY p_table_privileges LOOP
                        v_sql := format('GRANT %s ON ALL TABLES IN SCHEMA %I TO %I;', v_priv, v_schema, v_role);
                        IF p_execute_flag THEN EXECUTE v_sql; END IF;
                        v_log_status := CASE WHEN p_execute_flag THEN 'EXECUTED' ELSE 'DRY_RUN' END;
                        INSERT INTO info.account_log_history (action_type, target_entity, associated_entity, status, sql_command, message)
                        VALUES ('GRANT_TABLES', v_role, v_schema, v_log_status, v_sql, 'Granted table privilege');
                        v_log := v_log || v_sql || E'\n';
                    END LOOP;
                END IF;

                IF p_function_privileges IS NOT NULL THEN
                    FOREACH v_priv IN ARRAY p_function_privileges LOOP
                        v_sql := format('GRANT %s ON ALL FUNCTIONS IN SCHEMA %I TO %I;', v_priv, v_schema, v_role);
                        IF p_execute_flag THEN EXECUTE v_sql; END IF;
                        v_log_status := CASE WHEN p_execute_flag THEN 'EXECUTED' ELSE 'DRY_RUN' END;
                        INSERT INTO info.account_log_history (action_type, target_entity, associated_entity, status, sql_command, message)
                        VALUES ('GRANT_FUNCTIONS', v_role, v_schema, v_log_status, v_sql, 'Granted function privilege');
                        v_log := v_log || v_sql || E'\n';
                    END LOOP;
                END IF;

                IF p_set_default_for_future_tables AND p_table_privileges IS NOT NULL THEN
                    FOREACH v_priv IN ARRAY p_table_privileges LOOP
                        v_sql := format('ALTER DEFAULT PRIVILEGES FOR ROLE dba_team IN SCHEMA %I GRANT %s ON TABLES TO %I;', v_schema, v_priv, v_role);
                        IF p_execute_flag THEN EXECUTE v_sql; END IF;
                        v_log_status := CASE WHEN p_execute_flag THEN 'EXECUTED' ELSE 'DRY_RUN' END;
                        INSERT INTO info.account_log_history (action_type, target_entity, associated_entity, status, sql_command, message)
                        VALUES ('DEFAULT_TABLES', v_role, v_schema, v_log_status, v_sql, 'Default table privilege set');
                        v_log := v_log || v_sql || E'\n';
                    END LOOP;
                END IF;

                IF p_set_default_for_future_functions AND p_function_privileges IS NOT NULL THEN
                    FOREACH v_priv IN ARRAY p_function_privileges LOOP
                        v_sql := format('ALTER DEFAULT PRIVILEGES FOR ROLE dba_team IN SCHEMA %I GRANT %s ON FUNCTIONS TO %I;', v_schema, v_priv, v_role);
                        IF p_execute_flag THEN EXECUTE v_sql; END IF;
                        v_log_status := CASE WHEN p_execute_flag THEN 'EXECUTED' ELSE 'DRY_RUN' END;
                        INSERT INTO info.account_log_history (action_type, target_entity, associated_entity, status, sql_command, message)
                        VALUES ('DEFAULT_FUNCTIONS', v_role, v_schema, v_log_status, v_sql, 'Default function privilege set');
                        v_log := v_log || v_sql || E'\n';
                    END LOOP;
                END IF;
            END LOOP;
        END IF;
    END LOOP;
    RETURN v_log;
END;
$$;

ALTER FUNCTION deploy.setrolepermissions(
    TEXT[], TEXT[], TEXT[], TEXT[], TEXT[],
    BOOLEAN, BOOLEAN, BOOLEAN, BOOLEAN, BOOLEAN
) OWNER TO dba_team;
--- END FAILED SCRIPT ---
üìÑ [DBA] /c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/2 deploy/deploy.createschemawithpermissions.sql
üîó Running: psql -U "jrussell" -h "psqltstawrd01.clm0vrvchewi.us-east-2.rds.amazonaws.com" -p "5432" -d DBA -f "/c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/2 deploy/deploy.createschemawithpermissions.sql"
psql: error: connection to server at "psqltstawrd01.clm0vrvchewi.us-east-2.rds.amazonaws.com" (172.31.26.43), port 5432 failed: FATAL:  database "DBA" does not exist
‚ùå ERROR running /c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/2 deploy/deploy.createschemawithpermissions.sql against DBA
--- FAILED COMMAND ---
psql -U "jrussell" -h "psqltstawrd01.clm0vrvchewi.us-east-2.rds.amazonaws.com" -p "5432" -d DBA -f "/c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/2 deploy/deploy.createschemawithpermissions.sql"
--- BEGIN FAILED SCRIPT: /c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/2 deploy/deploy.createschemawithpermissions.sql ---
-- FUNCTION: deploy.createschemawithpermissions(text, text, text[], boolean)
set role dba_team; 
-- DROP FUNCTION IF EXISTS deploy.createschemawithpermissions(text, text, text[], boolean);

CREATE OR REPLACE FUNCTION deploy.createschemawithpermissions(
	p_schema_name text,
	p_owner text,
	p_grant_roles text[] DEFAULT NULL::text[],
	p_execute_flag boolean DEFAULT false)
    RETURNS text
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
/*
============================================================
 USAGE EXAMPLES: deploy.CreateSchemaWithPermissions()
============================================================

-- √∞≈∏¬ß¬™ Dry-run mode
SELECT deploy.CreateSchemaWithPermissions(
    p_schema_name := 'audit',
    p_owner := 'jrussell',
    p_grant_roles := ARRAY['db_datareader', 'db_datawriter', 'db_ddladmin'],
    p_execute_flag := FALSE
);

--  Execute schema creation with role grants and default privileges
SELECT deploy.CreateSchemaWithPermissions(
    p_schema_name := 'audit',
    p_owner := 'jrussell',
    p_grant_roles := ARRAY['db_datareader', 'db_datawriter', 'db_ddladmin'],
    p_execute_flag := TRUE
);

-- Will skip creation if schema exists
SELECT deploy.CreateSchemaWithPermissions('public', 'postgres', ARRAY['readonly'], TRUE);
============================================================
*/

DECLARE
    v_exists BOOLEAN;
    v_sql TEXT;
    v_role TEXT;
    v_log_status TEXT;
BEGIN
    -- Check if schema already exists
    SELECT EXISTS (
        SELECT 1 FROM information_schema.schemata WHERE schema_name = p_schema_name
    ) INTO v_exists;

    IF v_exists THEN
        v_log_status := 'ALREADY_EXISTS';
        RAISE NOTICE 'Schema "%" already exists.', p_schema_name;

        INSERT INTO info.object_log_history (
            action_type, target_entity, associated_entity, status, sql_command, message
        ) VALUES (
            'CREATE_SCHEMA',
            p_schema_name,
            p_owner,
            v_log_status,
            NULL,
            'Schema already existed. No action taken.'
        );

        RETURN format('Schema "%s" already exists.', p_schema_name);
    END IF;

    --Create schema
    v_sql := format('CREATE SCHEMA %I AUTHORIZATION %I', p_schema_name, p_owner);
    RAISE NOTICE '[DRY-RUN] Would create schema: %', p_schema_name;

    IF p_execute_flag THEN
        EXECUTE v_sql;
        v_log_status := 'EXECUTED';
        RAISE NOTICE 'Schema "%" created.', p_schema_name;
    ELSE
        v_log_status := 'DRY_RUN';
    END IF;

    INSERT INTO info.object_log_history (
        action_type, target_entity, associated_entity, status, sql_command, message
    ) VALUES (
        'CREATE_SCHEMA',
        p_schema_name,
        p_owner,
        v_log_status,
        v_sql,
        'Schema creation completed.'
    );

    -- Grant USAGE on schema
    IF p_grant_roles IS NOT NULL THEN
        FOREACH v_role IN ARRAY p_grant_roles LOOP
            v_sql := format('GRANT USAGE ON SCHEMA %I TO %I', p_schema_name, v_role);

            IF p_execute_flag THEN
                EXECUTE v_sql;
                v_log_status := 'EXECUTED';
            ELSE
                v_log_status := 'DRY_RUN';
            END IF;

            INSERT INTO info.object_log_history (
                action_type, target_entity, associated_entity, status, sql_command, message
            ) VALUES (
                'GRANT_SCHEMA_USAGE',
                v_role,
                p_schema_name,
                v_log_status,
                v_sql,
                format('Granted USAGE on schema "%s" to "%s".', p_schema_name, v_role)
            );
        END LOOP;
    END IF;

    -- Set default privileges for future tables
    IF p_execute_flag THEN
        -- db_datareader: SELECT
        v_sql := format('ALTER DEFAULT PRIVILEGES FOR ROLE %I IN SCHEMA %I GRANT SELECT ON TABLES TO db_datareader', p_owner, p_schema_name);
        EXECUTE v_sql;
        INSERT INTO info.object_log_history VALUES (
            DEFAULT, now(), 'DEFAULT_PRIVS', p_schema_name, 'db_datareader', 'EXECUTED', v_sql,
            'Granted default SELECT privileges to db_datareader.');

        -- db_datawriter: INSERT/UPDATE/DELETE/SELECT
        v_sql := format('ALTER DEFAULT PRIVILEGES FOR ROLE %I IN SCHEMA %I GRANT DELETE, INSERT, SELECT, UPDATE ON TABLES TO db_datawriter', p_owner, p_schema_name);
        EXECUTE v_sql;
        INSERT INTO info.object_log_history VALUES (
            DEFAULT, now(), 'DEFAULT_PRIVS', p_schema_name, 'db_datawriter', 'EXECUTED', v_sql,
            'Granted default DML privileges to db_datawriter.');

        -- db_ddladmin: ALL
        v_sql := format('ALTER DEFAULT PRIVILEGES FOR ROLE %I IN SCHEMA %I GRANT ALL ON TABLES TO db_ddladmin', p_owner, p_schema_name);
        EXECUTE v_sql;
        INSERT INTO info.object_log_history VALUES (
            DEFAULT, now(), 'DEFAULT_PRIVS', p_schema_name, 'db_ddladmin', 'EXECUTED', v_sql,
            'Granted default ALL privileges to db_ddladmin.');
    END IF;

    RETURN format('Schema "%s" processed with usage and default table privileges.', p_schema_name);
END;
$BODY$;

ALTER FUNCTION deploy.createschemawithpermissions(text, text, text[], boolean)
    OWNER TO dba_team;
--- END FAILED SCRIPT ---
üìÑ [DBA] /c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/3 info/info.GetPrivileges.sql
üîó Running: psql -U "jrussell" -h "psqltstawrd01.clm0vrvchewi.us-east-2.rds.amazonaws.com" -p "5432" -d DBA -f "/c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/3 info/info.GetPrivileges.sql"
psql: error: connection to server at "psqltstawrd01.clm0vrvchewi.us-east-2.rds.amazonaws.com" (172.31.26.43), port 5432 failed: FATAL:  database "DBA" does not exist
‚ùå ERROR running /c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/3 info/info.GetPrivileges.sql against DBA
--- FAILED COMMAND ---
psql -U "jrussell" -h "psqltstawrd01.clm0vrvchewi.us-east-2.rds.amazonaws.com" -p "5432" -d DBA -f "/c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/3 info/info.GetPrivileges.sql"
--- BEGIN FAILED SCRIPT: /c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/3 info/info.GetPrivileges.sql ---
-- ============================================
-- Function: dynamic schema.GetPrivileges(p_role TEXT DEFAULT '')
-- Purpose: Retrieve role privileges across schemas and database
-- Version-safe: Includes default ACL parsing only if PG >= 140000
-- ============================================
set role dba_team;

DO $$
DECLARE
    v_sql TEXT;
    v_schema TEXT;
    v_version INT := current_setting('server_version_num')::INT;
BEGIN
    -- Determine the schema for the function based on the current database
    IF current_database() = 'DBA' THEN
        v_schema := 'info';
    ELSIF current_database() IN ('postgres', 'rdsadmin') THEN
        RAISE NOTICE 'Skipping function creation in system DB: %', current_database();
        RETURN; -- Exit if in a system database
    ELSE
        v_schema := 'dba';
    END IF;

    -- Construct the dynamic SQL for creating or replacing the function
    v_sql := '
    CREATE OR REPLACE FUNCTION ' || quote_ident(v_schema) || '.GetPrivileges(p_role TEXT DEFAULT '''')
    RETURNS TABLE (
        object_scope TEXT,
        grantee TEXT,
        privilege TEXT,
        inherited_role TEXT,
        source TEXT
    )
    LANGUAGE plpgsql AS
    $func$
    DECLARE
        v_ver INT := current_setting(''server_version_num'')::INT;
    BEGIN
        RETURN QUERY
        -- CTE to get roles and their directly inherited roles
        WITH inherited_roles AS (
            SELECT
                r.rolname AS role_name,
                string_agg(m.rolname, '','' ORDER BY m.rolname) AS inherited_role
            FROM pg_roles r
            LEFT JOIN pg_auth_members am ON r.oid = am.member
            LEFT JOIN pg_roles m ON am.roleid = m.oid
            GROUP BY r.rolname
        ),
        -- CTE for schema CREATE privileges
        schema_create AS (
            SELECT
                n.nspname::TEXT AS object_scope,
                r.rolname::TEXT AS grantee,
                ''CREATE''::TEXT AS privilege,
                ir.inherited_role,
                ''actual_schema_privilege''::TEXT AS source
            FROM pg_namespace n
            JOIN pg_roles r ON has_schema_privilege(r.rolname, n.oid, ''CREATE'')
            LEFT JOIN inherited_roles ir ON r.rolname = ir.role_name
            WHERE n.nspname NOT LIKE ''pg_%'' AND n.nspname <> ''information_schema''
        ),
        -- CTE for schema USAGE privileges
        schema_usage AS (
            SELECT
                n.nspname::TEXT AS object_scope,
                r.rolname::TEXT AS grantee,
                ''USAGE''::TEXT AS privilege,
                ir.inherited_role,
                ''actual_schema_privilege''::TEXT AS source
            FROM pg_namespace n
            JOIN pg_roles r ON has_schema_privilege(r.rolname, n.oid, ''USAGE'')
            LEFT JOIN inherited_roles ir ON r.rolname = ir.role_name
            WHERE n.nspname NOT LIKE ''pg_%'' AND n.nspname <> ''information_schema''
        ),
        -- CTE for database-level privileges (CREATE, TEMP, CONNECT)
        db_privs AS (
            SELECT
                current_database()::TEXT AS object_scope,
                r.rolname::TEXT AS grantee,
                unnest(string_to_array(
                    TRIM(BOTH '','' FROM
                        CASE WHEN has_database_privilege(r.rolname, current_database(), ''CREATE'') THEN ''CREATE,'' ELSE '''' END ||
                        CASE WHEN has_database_privilege(r.rolname, current_database(), ''TEMP'') THEN ''TEMP,'' ELSE '''' END ||
                        CASE WHEN has_database_privilege(r.rolname, current_database(), ''CONNECT'') THEN ''CONNECT'' ELSE '''' END
                    ), '',''))::TEXT AS privilege,
                ir.inherited_role,
                ''actual_database_privilege''::TEXT AS source
            FROM pg_roles r
            LEFT JOIN inherited_roles ir ON r.rolname = ir.role_name
        ),
        -- CTE to extract raw ACL entries from pg_default_acl for PG 14+
        raw_acls AS (
            SELECT
                pda.defaclnamespace::regnamespace::TEXT AS object_scope,
                (regexp_matches(acl_entry::TEXT, ''^(.+?)=([a-zA-Z]*)/?(.+)?$''))[1]::TEXT AS grantee,
                (regexp_matches(acl_entry::TEXT, ''^(.+?)=([a-zA-Z]*)/?(.+)?$''))[2]::TEXT AS privs_raw
            FROM pg_default_acl pda, unnest(pda.defaclacl) AS acl_entry
            WHERE current_setting(''server_version_num'')::INT >= 140000
        ),
        -- CTE to expand raw ACL characters into full privilege names
        expanded_acls AS (
            SELECT
                ra.object_scope,
                ra.grantee,
                CASE
                    WHEN ra.privs_raw IS NULL THEN NULL
                    ELSE array_to_string(ARRAY(
                        SELECT priv_subquery.privilege FROM (
                            SELECT CASE WHEN ra.privs_raw LIKE ''%a%'' THEN ''INSERT'' END AS privilege
                            UNION ALL SELECT CASE WHEN ra.privs_raw LIKE ''%r%'' THEN ''SELECT'' END
                            UNION ALL SELECT CASE WHEN ra.privs_raw LIKE ''%w%'' THEN ''UPDATE'' END
                            UNION ALL SELECT CASE WHEN ra.privs_raw LIKE ''%d%'' THEN ''DELETE'' END
                            UNION ALL SELECT CASE WHEN ra.privs_raw LIKE ''%D%'' THEN ''TRUNCATE'' END
                            UNION ALL SELECT CASE WHEN ra.privs_raw LIKE ''%x%'' THEN ''REFERENCES'' END
                            UNION ALL SELECT CASE WHEN ra.privs_raw LIKE ''%t%'' THEN ''TRIGGER'' END
                            UNION ALL SELECT CASE WHEN ra.privs_raw LIKE ''%X%'' THEN ''EXECUTE'' END
                        ) AS priv_subquery WHERE priv_subquery.privilege IS NOT NULL ORDER BY priv_subquery.privilege
                    ), '','')
                END AS privilege,
                ir.inherited_role,
                ''default_acl''::TEXT AS source
            FROM raw_acls ra
            LEFT JOIN inherited_roles ir ON ra.grantee = ir.role_name
        )

        -- Combine all privilege types and filter by p_role if provided
        SELECT sc.object_scope, sc.grantee, sc.privilege, sc.inherited_role, sc.source FROM schema_create sc WHERE p_role = '''' OR sc.grantee = p_role
        UNION ALL
        SELECT su.object_scope, su.grantee, su.privilege, su.inherited_role, su.source FROM schema_usage su WHERE p_role = '''' OR su.grantee = p_role
        UNION ALL
        SELECT db.object_scope, db.grantee, db.privilege, db.inherited_role, db.source FROM db_privs db WHERE p_role = '''' OR db.grantee = p_role
        UNION ALL
        SELECT ea.object_scope, ea.grantee, ea.privilege, ea.inherited_role, ea.source FROM expanded_acls ea WHERE p_role = '''' OR ea.grantee = p_role
        ORDER BY grantee, object_scope, privilege;
    END;
    $func$;
    ';

    -- Execute the dynamically constructed SQL to create the function
    EXECUTE v_sql;
END $$;
--- END FAILED SCRIPT ---
üìÑ [DBA] /c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/3 info/info.SetPassword.sql
üîó Running: psql -U "jrussell" -h "psqltstawrd01.clm0vrvchewi.us-east-2.rds.amazonaws.com" -p "5432" -d DBA -f "/c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/3 info/info.SetPassword.sql"
psql: error: connection to server at "psqltstawrd01.clm0vrvchewi.us-east-2.rds.amazonaws.com" (172.31.26.43), port 5432 failed: FATAL:  database "DBA" does not exist
‚ùå ERROR running /c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/3 info/info.SetPassword.sql against DBA
--- FAILED COMMAND ---
psql -U "jrussell" -h "psqltstawrd01.clm0vrvchewi.us-east-2.rds.amazonaws.com" -p "5432" -d DBA -f "/c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/3 info/info.SetPassword.sql"
--- BEGIN FAILED SCRIPT: /c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/3 info/info.SetPassword.sql ---
-- ‚úÖ PostgreSQL-Compatible Password Audit Setup
-- Filename: 13_info.SetPassword_FIXED.sql

-- ============================================================
-- STEP 1: Ensure info schema exists
-- ============================================================
set role dba_team; 


DO $$
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM pg_namespace WHERE nspname = 'info'
    ) THEN
        EXECUTE 'CREATE SCHEMA info AUTHORIZATION current_user';
        RAISE NOTICE 'Schema "info" created.';
    ELSE
        RAISE NOTICE 'Schema "info" already exists.';
    END IF;
END
$$;

-- ============================================================
-- STEP 2: Create info.password_change_audit table safely
-- ============================================================

DO $$
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.tables 
        WHERE table_schema = 'info' AND table_name = 'password_change_audit'
    ) THEN
        CREATE TABLE info.password_change_audit (
            audit_id SERIAL PRIMARY KEY,
            changed_at TIMESTAMPTZ DEFAULT now(),
            changed_by TEXT NOT NULL,
            changed_user TEXT NOT NULL,
            note TEXT
        );

        ALTER TABLE info.password_change_audit OWNER TO dba_team;

        REVOKE ALL ON TABLE info.password_change_audit FROM db_datareader;
        REVOKE ALL ON TABLE info.password_change_audit FROM db_datawriter;

        GRANT SELECT ON TABLE info.password_change_audit TO db_datareader;
        GRANT INSERT, SELECT, UPDATE, DELETE ON TABLE info.password_change_audit TO db_datawriter;
        GRANT ALL ON TABLE info.password_change_audit TO db_ddladmin;
        GRANT ALL ON TABLE info.password_change_audit TO dba_team;

        RAISE NOTICE 'Table "info.password_change_audit" created.';
    ELSE
        RAISE NOTICE 'Table "info.password_change_audit" already exists.';
    END IF;
END
$$;

-- ============================================================
-- STEP 3: Create SetPassword Function
-- ============================================================

CREATE OR REPLACE FUNCTION info.SetPassword(
    target_username TEXT,
    new_password TEXT
)
RETURNS VOID AS
$$
DECLARE
    caller TEXT := session_user;
BEGIN
    -- Input validation
    IF target_username IS NULL OR trim(target_username) = '' THEN
        RAISE EXCEPTION 'Username cannot be null or empty';
    END IF;

    IF new_password IS NULL OR trim(new_password) = '' THEN
        RAISE EXCEPTION 'Password cannot be null or empty';
    END IF;

    IF length(new_password) < 9 THEN
        RAISE EXCEPTION 'Password must be at least 12 characters long';
    END IF;

    IF lower(target_username) = 'postgres' THEN
        RAISE EXCEPTION 'Changing password for superuser "postgres" is not allowed through this function';
    END IF;

    -- Explicit check for user existence
    IF EXISTS (SELECT 1 FROM pg_roles WHERE rolname = target_username) THEN
        EXECUTE format('ALTER ROLE %I WITH PASSWORD %L', target_username, new_password);

        INSERT INTO info.password_change_audit (changed_by, changed_user, note)
        VALUES (caller, target_username, 'Password changed via info.safe_change_password');

        RAISE NOTICE 'SUCCESS: Password changed for user %', target_username;
    ELSE
        RAISE EXCEPTION 'User "%" does not exist', target_username;
    END IF;
END;
$$
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = info, public;

-- Helper usage reminder
DO $$
BEGIN
    RAISE NOTICE 'To execute password change: SELECT info.SetPassword(''username'', ''newPassword'');';
END
$$ LANGUAGE plpgsql;
--- END FAILED SCRIPT ---
üìÑ [DBA] /c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/3 info/info.sp_whoisactive.sql
üîó Running: psql -U "jrussell" -h "psqltstawrd01.clm0vrvchewi.us-east-2.rds.amazonaws.com" -p "5432" -d DBA -f "/c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/3 info/info.sp_whoisactive.sql"
psql: error: connection to server at "psqltstawrd01.clm0vrvchewi.us-east-2.rds.amazonaws.com" (172.31.26.43), port 5432 failed: FATAL:  database "DBA" does not exist
‚ùå ERROR running /c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/3 info/info.sp_whoisactive.sql against DBA
--- FAILED COMMAND ---
psql -U "jrussell" -h "psqltstawrd01.clm0vrvchewi.us-east-2.rds.amazonaws.com" -p "5432" -d DBA -f "/c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/3 info/info.sp_whoisactive.sql"
--- BEGIN FAILED SCRIPT: /c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/3 info/info.sp_whoisactive.sql ---
set role dba_team; 


CREATE OR REPLACE FUNCTION info.sp_whoisactive (
    p_database_name TEXT DEFAULT NULL,
    p_show_idle_in_transaction BOOLEAN DEFAULT FALSE,
    p_show_all_idle BOOLEAN DEFAULT FALSE
)
RETURNS TABLE (
    duration INTERVAL,
    pid INT,
    datname NAME,
    usename NAME,
    application_name TEXT,
    client_addr INET,
    backend_start TIMESTAMPTZ,
    xact_start TIMESTAMPTZ,
    query_start TIMESTAMPTZ,
    state_change TIMESTAMPTZ,
    state TEXT,
    wait_event_type TEXT,
    wait_event TEXT,
    query TEXT
)
LANGUAGE plpgsql
AS $$
BEGIN
    RETURN QUERY
    SELECT
        NOW() - sa.query_start AS duration,
        sa.pid,
        sa.datname,
        sa.usename,
        sa.application_name,
        sa.client_addr,
        sa.backend_start,
        sa.xact_start,
        sa.query_start,
        sa.state_change,
        sa.state,
        sa.wait_event_type,
        sa.wait_event,
        sa.query
    FROM
        pg_stat_activity sa
    WHERE
        sa.pid <> pg_backend_pid()
        AND (
            p_show_all_idle
            OR
            (
                NOT p_show_all_idle AND NOT p_show_idle_in_transaction AND sa.state <> 'idle'
            )
            OR
            (
                NOT p_show_all_idle AND p_show_idle_in_transaction AND sa.state <> 'idle' OR sa.state ILIKE 'idle in transaction%'
            )
        )
        AND (p_database_name IS NULL OR sa.datname = p_database_name)
    ORDER BY
        sa.query_start DESC;
END;
$$;--- END FAILED SCRIPT ---
üìÑ [DBA] /c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/4 admin/admin.SetDBOffline.sql
üîó Running: psql -U "jrussell" -h "psqltstawrd01.clm0vrvchewi.us-east-2.rds.amazonaws.com" -p "5432" -d DBA -f "/c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/4 admin/admin.SetDBOffline.sql"
psql: error: connection to server at "psqltstawrd01.clm0vrvchewi.us-east-2.rds.amazonaws.com" (172.31.26.43), port 5432 failed: FATAL:  database "DBA" does not exist
‚ùå ERROR running /c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/4 admin/admin.SetDBOffline.sql against DBA
--- FAILED COMMAND ---
psql -U "jrussell" -h "psqltstawrd01.clm0vrvchewi.us-east-2.rds.amazonaws.com" -p "5432" -d DBA -f "/c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/4 admin/admin.SetDBOffline.sql"
--- BEGIN FAILED SCRIPT: /c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/4 admin/admin.SetDBOffline.sql ---
-- ================================================
-- FUNCTION: admin.SetDatabaseConnectionLimit
-- PURPOSE: Set a database's connection limit and log the change
-- ================================================
set role dba_team; 

CREATE OR REPLACE FUNCTION admin.SetDBOffline(
    target_db TEXT,
    connection_limit INT
)
RETURNS TEXT
LANGUAGE plpgsql
AS $$
DECLARE
    action_label TEXT;
    status_label TEXT := 'SUCCESS';
    command_executed TEXT;
BEGIN
    -- Build the SQL command
    command_executed := format('ALTER DATABASE %I CONNECTION LIMIT %s;', target_db, connection_limit);
    EXECUTE command_executed;

    -- Define action type
    action_label := CASE
        WHEN connection_limit = 0 THEN 'Set DB Offline'
        WHEN connection_limit = -1 THEN 'Set DB Online'
        ELSE 'Set DB Conn Limit: ' || connection_limit::TEXT
    END;

    -- Log the event
    INSERT INTO info.object_log_history (
        action_type,
        target_entity,
        associated_entity,
        status,
        sql_command,
        message
    )
    VALUES (
        action_label,
        target_db,
        current_user,
        status_label,
        command_executed,
        format('Connection limit set to %s', connection_limit)
    );

    RETURN format('Database %s connection limit set to %s', target_db, connection_limit);
END $$;
--- END FAILED SCRIPT ---
üîÅ Running on InventoryDWH...
üìÑ [InventoryDWH] /c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/5 other/dba.GetPrivileges.sql
üîó Running: psql -U "jrussell" -h "psqltstawrd01.clm0vrvchewi.us-east-2.rds.amazonaws.com" -p "5432" -d "InventoryDWH" -f "/c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/5 other/dba.GetPrivileges.sql"
psql: error: connection to server at "psqltstawrd01.clm0vrvchewi.us-east-2.rds.amazonaws.com" (172.31.26.43), port 5432 failed: FATAL:  database "InventoryDWH" does not exist
‚ùå ERROR running /c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/5 other/dba.GetPrivileges.sql against InventoryDWH
--- FAILED COMMAND ---
psql -U "jrussell" -h "psqltstawrd01.clm0vrvchewi.us-east-2.rds.amazonaws.com" -p "5432" -d "InventoryDWH" -f "/c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/5 other/dba.GetPrivileges.sql"
--- BEGIN FAILED SCRIPT: /c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/5 other/dba.GetPrivileges.sql ---
-- ============================================
-- Function: dynamic schema.GetPrivileges(p_role TEXT DEFAULT '')
-- Purpose: Retrieve role privileges across schemas and database
-- Version-safe: Includes default ACL parsing only if PG >= 140000
-- ============================================
set role dba_team; 

DO $$
DECLARE
    v_sql TEXT;
    v_schema TEXT;
    v_version INT := current_setting('server_version_num')::INT;
BEGIN
    -- Determine the schema for the function based on the current database
    IF current_database() = 'DBA' THEN
        v_schema := 'info';
    ELSIF current_database() IN ('postgres', 'rdsadmin') THEN
        RAISE NOTICE 'Skipping function creation in system DB: %', current_database();
        RETURN; -- Exit if in a system database
    ELSE
        v_schema := 'dba';
    END IF;

    -- Construct the dynamic SQL for creating or replacing the function
    v_sql := '
    CREATE OR REPLACE FUNCTION ' || quote_ident(v_schema) || '.GetPrivileges(p_role TEXT DEFAULT '''')
    RETURNS TABLE (
        object_scope TEXT,
        grantee TEXT,
        privilege TEXT,
        inherited_role TEXT,
        source TEXT
    )
    LANGUAGE plpgsql AS
    $func$
    DECLARE
        v_ver INT := current_setting(''server_version_num'')::INT;
    BEGIN
        RETURN QUERY
        -- CTE to get roles and their directly inherited roles
        WITH inherited_roles AS (
            SELECT
                r.rolname AS role_name,
                string_agg(m.rolname, '','' ORDER BY m.rolname) AS inherited_role
            FROM pg_roles r
            LEFT JOIN pg_auth_members am ON r.oid = am.member
            LEFT JOIN pg_roles m ON am.roleid = m.oid
            GROUP BY r.rolname
        ),
        -- CTE for schema CREATE privileges
        schema_create AS (
            SELECT
                n.nspname::TEXT AS object_scope,
                r.rolname::TEXT AS grantee,
                ''CREATE''::TEXT AS privilege,
                ir.inherited_role,
                ''actual_schema_privilege''::TEXT AS source
            FROM pg_namespace n
            JOIN pg_roles r ON has_schema_privilege(r.rolname, n.oid, ''CREATE'')
            LEFT JOIN inherited_roles ir ON r.rolname = ir.role_name
            WHERE n.nspname NOT LIKE ''pg_%'' AND n.nspname <> ''information_schema''
        ),
        -- CTE for schema USAGE privileges
        schema_usage AS (
            SELECT
                n.nspname::TEXT AS object_scope,
                r.rolname::TEXT AS grantee,
                ''USAGE''::TEXT AS privilege,
                ir.inherited_role,
                ''actual_schema_privilege''::TEXT AS source
            FROM pg_namespace n
            JOIN pg_roles r ON has_schema_privilege(r.rolname, n.oid, ''USAGE'')
            LEFT JOIN inherited_roles ir ON r.rolname = ir.role_name
            WHERE n.nspname NOT LIKE ''pg_%'' AND n.nspname <> ''information_schema''
        ),
        -- CTE for database-level privileges (CREATE, TEMP, CONNECT)
        db_privs AS (
            SELECT
                current_database()::TEXT AS object_scope,
                r.rolname::TEXT AS grantee,
                unnest(string_to_array(
                    TRIM(BOTH '','' FROM
                        CASE WHEN has_database_privilege(r.rolname, current_database(), ''CREATE'') THEN ''CREATE,'' ELSE '''' END ||
                        CASE WHEN has_database_privilege(r.rolname, current_database(), ''TEMP'') THEN ''TEMP,'' ELSE '''' END ||
                        CASE WHEN has_database_privilege(r.rolname, current_database(), ''CONNECT'') THEN ''CONNECT'' ELSE '''' END
                    ), '',''))::TEXT AS privilege,
                ir.inherited_role,
                ''actual_database_privilege''::TEXT AS source
            FROM pg_roles r
            LEFT JOIN inherited_roles ir ON r.rolname = ir.role_name
        ),
        -- CTE to extract raw ACL entries from pg_default_acl for PG 14+
        raw_acls AS (
            SELECT
                pda.defaclnamespace::regnamespace::TEXT AS object_scope,
                (regexp_matches(acl_entry::TEXT, ''^(.+?)=([a-zA-Z]*)/?(.+)?$''))[1]::TEXT AS grantee,
                (regexp_matches(acl_entry::TEXT, ''^(.+?)=([a-zA-Z]*)/?(.+)?$''))[2]::TEXT AS privs_raw
            FROM pg_default_acl pda, unnest(pda.defaclacl) AS acl_entry
            WHERE current_setting(''server_version_num'')::INT >= 140000
        ),
        -- CTE to expand raw ACL characters into full privilege names
        expanded_acls AS (
            SELECT
                ra.object_scope,
                ra.grantee,
                CASE
                    WHEN ra.privs_raw IS NULL THEN NULL
                    ELSE array_to_string(ARRAY(
                        SELECT priv_subquery.privilege FROM (
                            SELECT CASE WHEN ra.privs_raw LIKE ''%a%'' THEN ''INSERT'' END AS privilege
                            UNION ALL SELECT CASE WHEN ra.privs_raw LIKE ''%r%'' THEN ''SELECT'' END
                            UNION ALL SELECT CASE WHEN ra.privs_raw LIKE ''%w%'' THEN ''UPDATE'' END
                            UNION ALL SELECT CASE WHEN ra.privs_raw LIKE ''%d%'' THEN ''DELETE'' END
                            UNION ALL SELECT CASE WHEN ra.privs_raw LIKE ''%D%'' THEN ''TRUNCATE'' END
                            UNION ALL SELECT CASE WHEN ra.privs_raw LIKE ''%x%'' THEN ''REFERENCES'' END
                            UNION ALL SELECT CASE WHEN ra.privs_raw LIKE ''%t%'' THEN ''TRIGGER'' END
                            UNION ALL SELECT CASE WHEN ra.privs_raw LIKE ''%X%'' THEN ''EXECUTE'' END
                        ) AS priv_subquery WHERE priv_subquery.privilege IS NOT NULL ORDER BY priv_subquery.privilege
                    ), '','')
                END AS privilege,
                ir.inherited_role,
                ''default_acl''::TEXT AS source
            FROM raw_acls ra
            LEFT JOIN inherited_roles ir ON ra.grantee = ir.role_name
        )

        -- Combine all privilege types and filter by p_role if provided
        SELECT sc.object_scope, sc.grantee, sc.privilege, sc.inherited_role, sc.source FROM schema_create sc WHERE p_role = '''' OR sc.grantee = p_role
        UNION ALL
        SELECT su.object_scope, su.grantee, su.privilege, su.inherited_role, su.source FROM schema_usage su WHERE p_role = '''' OR su.grantee = p_role
        UNION ALL
        SELECT db.object_scope, db.grantee, db.privilege, db.inherited_role, db.source FROM db_privs db WHERE p_role = '''' OR db.grantee = p_role
        UNION ALL
        SELECT ea.object_scope, ea.grantee, ea.privilege, ea.inherited_role, ea.source FROM expanded_acls ea WHERE p_role = '''' OR ea.grantee = p_role
        ORDER BY grantee, object_scope, privilege;
    END;
    $func$;
    ';

    -- Execute the dynamically constructed SQL to create the function
    EXECUTE v_sql;
END $$;
--- END FAILED SCRIPT ---
üîÅ Running on dba_jcr...
üìÑ [dba_jcr] /c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/5 other/dba.GetPrivileges.sql
üîó Running: psql -U "jrussell" -h "psqltstawrd01.clm0vrvchewi.us-east-2.rds.amazonaws.com" -p "5432" -d "dba_jcr" -f "/c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/5 other/dba.GetPrivileges.sql"
psql: error: connection to server at "psqltstawrd01.clm0vrvchewi.us-east-2.rds.amazonaws.com" (172.31.26.43), port 5432 failed: FATAL:  database "dba_jcr" does not exist
‚ùå ERROR running /c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/5 other/dba.GetPrivileges.sql against dba_jcr
--- FAILED COMMAND ---
psql -U "jrussell" -h "psqltstawrd01.clm0vrvchewi.us-east-2.rds.amazonaws.com" -p "5432" -d "dba_jcr" -f "/c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/5 other/dba.GetPrivileges.sql"
--- BEGIN FAILED SCRIPT: /c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/5 other/dba.GetPrivileges.sql ---
-- ============================================
-- Function: dynamic schema.GetPrivileges(p_role TEXT DEFAULT '')
-- Purpose: Retrieve role privileges across schemas and database
-- Version-safe: Includes default ACL parsing only if PG >= 140000
-- ============================================
set role dba_team; 

DO $$
DECLARE
    v_sql TEXT;
    v_schema TEXT;
    v_version INT := current_setting('server_version_num')::INT;
BEGIN
    -- Determine the schema for the function based on the current database
    IF current_database() = 'DBA' THEN
        v_schema := 'info';
    ELSIF current_database() IN ('postgres', 'rdsadmin') THEN
        RAISE NOTICE 'Skipping function creation in system DB: %', current_database();
        RETURN; -- Exit if in a system database
    ELSE
        v_schema := 'dba';
    END IF;

    -- Construct the dynamic SQL for creating or replacing the function
    v_sql := '
    CREATE OR REPLACE FUNCTION ' || quote_ident(v_schema) || '.GetPrivileges(p_role TEXT DEFAULT '''')
    RETURNS TABLE (
        object_scope TEXT,
        grantee TEXT,
        privilege TEXT,
        inherited_role TEXT,
        source TEXT
    )
    LANGUAGE plpgsql AS
    $func$
    DECLARE
        v_ver INT := current_setting(''server_version_num'')::INT;
    BEGIN
        RETURN QUERY
        -- CTE to get roles and their directly inherited roles
        WITH inherited_roles AS (
            SELECT
                r.rolname AS role_name,
                string_agg(m.rolname, '','' ORDER BY m.rolname) AS inherited_role
            FROM pg_roles r
            LEFT JOIN pg_auth_members am ON r.oid = am.member
            LEFT JOIN pg_roles m ON am.roleid = m.oid
            GROUP BY r.rolname
        ),
        -- CTE for schema CREATE privileges
        schema_create AS (
            SELECT
                n.nspname::TEXT AS object_scope,
                r.rolname::TEXT AS grantee,
                ''CREATE''::TEXT AS privilege,
                ir.inherited_role,
                ''actual_schema_privilege''::TEXT AS source
            FROM pg_namespace n
            JOIN pg_roles r ON has_schema_privilege(r.rolname, n.oid, ''CREATE'')
            LEFT JOIN inherited_roles ir ON r.rolname = ir.role_name
            WHERE n.nspname NOT LIKE ''pg_%'' AND n.nspname <> ''information_schema''
        ),
        -- CTE for schema USAGE privileges
        schema_usage AS (
            SELECT
                n.nspname::TEXT AS object_scope,
                r.rolname::TEXT AS grantee,
                ''USAGE''::TEXT AS privilege,
                ir.inherited_role,
                ''actual_schema_privilege''::TEXT AS source
            FROM pg_namespace n
            JOIN pg_roles r ON has_schema_privilege(r.rolname, n.oid, ''USAGE'')
            LEFT JOIN inherited_roles ir ON r.rolname = ir.role_name
            WHERE n.nspname NOT LIKE ''pg_%'' AND n.nspname <> ''information_schema''
        ),
        -- CTE for database-level privileges (CREATE, TEMP, CONNECT)
        db_privs AS (
            SELECT
                current_database()::TEXT AS object_scope,
                r.rolname::TEXT AS grantee,
                unnest(string_to_array(
                    TRIM(BOTH '','' FROM
                        CASE WHEN has_database_privilege(r.rolname, current_database(), ''CREATE'') THEN ''CREATE,'' ELSE '''' END ||
                        CASE WHEN has_database_privilege(r.rolname, current_database(), ''TEMP'') THEN ''TEMP,'' ELSE '''' END ||
                        CASE WHEN has_database_privilege(r.rolname, current_database(), ''CONNECT'') THEN ''CONNECT'' ELSE '''' END
                    ), '',''))::TEXT AS privilege,
                ir.inherited_role,
                ''actual_database_privilege''::TEXT AS source
            FROM pg_roles r
            LEFT JOIN inherited_roles ir ON r.rolname = ir.role_name
        ),
        -- CTE to extract raw ACL entries from pg_default_acl for PG 14+
        raw_acls AS (
            SELECT
                pda.defaclnamespace::regnamespace::TEXT AS object_scope,
                (regexp_matches(acl_entry::TEXT, ''^(.+?)=([a-zA-Z]*)/?(.+)?$''))[1]::TEXT AS grantee,
                (regexp_matches(acl_entry::TEXT, ''^(.+?)=([a-zA-Z]*)/?(.+)?$''))[2]::TEXT AS privs_raw
            FROM pg_default_acl pda, unnest(pda.defaclacl) AS acl_entry
            WHERE current_setting(''server_version_num'')::INT >= 140000
        ),
        -- CTE to expand raw ACL characters into full privilege names
        expanded_acls AS (
            SELECT
                ra.object_scope,
                ra.grantee,
                CASE
                    WHEN ra.privs_raw IS NULL THEN NULL
                    ELSE array_to_string(ARRAY(
                        SELECT priv_subquery.privilege FROM (
                            SELECT CASE WHEN ra.privs_raw LIKE ''%a%'' THEN ''INSERT'' END AS privilege
                            UNION ALL SELECT CASE WHEN ra.privs_raw LIKE ''%r%'' THEN ''SELECT'' END
                            UNION ALL SELECT CASE WHEN ra.privs_raw LIKE ''%w%'' THEN ''UPDATE'' END
                            UNION ALL SELECT CASE WHEN ra.privs_raw LIKE ''%d%'' THEN ''DELETE'' END
                            UNION ALL SELECT CASE WHEN ra.privs_raw LIKE ''%D%'' THEN ''TRUNCATE'' END
                            UNION ALL SELECT CASE WHEN ra.privs_raw LIKE ''%x%'' THEN ''REFERENCES'' END
                            UNION ALL SELECT CASE WHEN ra.privs_raw LIKE ''%t%'' THEN ''TRIGGER'' END
                            UNION ALL SELECT CASE WHEN ra.privs_raw LIKE ''%X%'' THEN ''EXECUTE'' END
                        ) AS priv_subquery WHERE priv_subquery.privilege IS NOT NULL ORDER BY priv_subquery.privilege
                    ), '','')
                END AS privilege,
                ir.inherited_role,
                ''default_acl''::TEXT AS source
            FROM raw_acls ra
            LEFT JOIN inherited_roles ir ON ra.grantee = ir.role_name
        )

        -- Combine all privilege types and filter by p_role if provided
        SELECT sc.object_scope, sc.grantee, sc.privilege, sc.inherited_role, sc.source FROM schema_create sc WHERE p_role = '''' OR sc.grantee = p_role
        UNION ALL
        SELECT su.object_scope, su.grantee, su.privilege, su.inherited_role, su.source FROM schema_usage su WHERE p_role = '''' OR su.grantee = p_role
        UNION ALL
        SELECT db.object_scope, db.grantee, db.privilege, db.inherited_role, db.source FROM db_privs db WHERE p_role = '''' OR db.grantee = p_role
        UNION ALL
        SELECT ea.object_scope, ea.grantee, ea.privilege, ea.inherited_role, ea.source FROM expanded_acls ea WHERE p_role = '''' OR ea.grantee = p_role
        ORDER BY grantee, object_scope, privilege;
    END;
    $func$;
    ';

    -- Execute the dynamically constructed SQL to create the function
    EXECUTE v_sql;
END $$;
--- END FAILED SCRIPT ---
üîÅ Running on Kineteco...
üìÑ [Kineteco] /c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/5 other/dba.GetPrivileges.sql
üîó Running: psql -U "jrussell" -h "psqltstawrd01.clm0vrvchewi.us-east-2.rds.amazonaws.com" -p "5432" -d "Kineteco" -f "/c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/5 other/dba.GetPrivileges.sql"
psql: error: connection to server at "psqltstawrd01.clm0vrvchewi.us-east-2.rds.amazonaws.com" (172.31.26.43), port 5432 failed: FATAL:  database "Kineteco" does not exist
‚ùå ERROR running /c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/5 other/dba.GetPrivileges.sql against Kineteco
--- FAILED COMMAND ---
psql -U "jrussell" -h "psqltstawrd01.clm0vrvchewi.us-east-2.rds.amazonaws.com" -p "5432" -d "Kineteco" -f "/c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/5 other/dba.GetPrivileges.sql"
--- BEGIN FAILED SCRIPT: /c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/5 other/dba.GetPrivileges.sql ---
-- ============================================
-- Function: dynamic schema.GetPrivileges(p_role TEXT DEFAULT '')
-- Purpose: Retrieve role privileges across schemas and database
-- Version-safe: Includes default ACL parsing only if PG >= 140000
-- ============================================
set role dba_team; 

DO $$
DECLARE
    v_sql TEXT;
    v_schema TEXT;
    v_version INT := current_setting('server_version_num')::INT;
BEGIN
    -- Determine the schema for the function based on the current database
    IF current_database() = 'DBA' THEN
        v_schema := 'info';
    ELSIF current_database() IN ('postgres', 'rdsadmin') THEN
        RAISE NOTICE 'Skipping function creation in system DB: %', current_database();
        RETURN; -- Exit if in a system database
    ELSE
        v_schema := 'dba';
    END IF;

    -- Construct the dynamic SQL for creating or replacing the function
    v_sql := '
    CREATE OR REPLACE FUNCTION ' || quote_ident(v_schema) || '.GetPrivileges(p_role TEXT DEFAULT '''')
    RETURNS TABLE (
        object_scope TEXT,
        grantee TEXT,
        privilege TEXT,
        inherited_role TEXT,
        source TEXT
    )
    LANGUAGE plpgsql AS
    $func$
    DECLARE
        v_ver INT := current_setting(''server_version_num'')::INT;
    BEGIN
        RETURN QUERY
        -- CTE to get roles and their directly inherited roles
        WITH inherited_roles AS (
            SELECT
                r.rolname AS role_name,
                string_agg(m.rolname, '','' ORDER BY m.rolname) AS inherited_role
            FROM pg_roles r
            LEFT JOIN pg_auth_members am ON r.oid = am.member
            LEFT JOIN pg_roles m ON am.roleid = m.oid
            GROUP BY r.rolname
        ),
        -- CTE for schema CREATE privileges
        schema_create AS (
            SELECT
                n.nspname::TEXT AS object_scope,
                r.rolname::TEXT AS grantee,
                ''CREATE''::TEXT AS privilege,
                ir.inherited_role,
                ''actual_schema_privilege''::TEXT AS source
            FROM pg_namespace n
            JOIN pg_roles r ON has_schema_privilege(r.rolname, n.oid, ''CREATE'')
            LEFT JOIN inherited_roles ir ON r.rolname = ir.role_name
            WHERE n.nspname NOT LIKE ''pg_%'' AND n.nspname <> ''information_schema''
        ),
        -- CTE for schema USAGE privileges
        schema_usage AS (
            SELECT
                n.nspname::TEXT AS object_scope,
                r.rolname::TEXT AS grantee,
                ''USAGE''::TEXT AS privilege,
                ir.inherited_role,
                ''actual_schema_privilege''::TEXT AS source
            FROM pg_namespace n
            JOIN pg_roles r ON has_schema_privilege(r.rolname, n.oid, ''USAGE'')
            LEFT JOIN inherited_roles ir ON r.rolname = ir.role_name
            WHERE n.nspname NOT LIKE ''pg_%'' AND n.nspname <> ''information_schema''
        ),
        -- CTE for database-level privileges (CREATE, TEMP, CONNECT)
        db_privs AS (
            SELECT
                current_database()::TEXT AS object_scope,
                r.rolname::TEXT AS grantee,
                unnest(string_to_array(
                    TRIM(BOTH '','' FROM
                        CASE WHEN has_database_privilege(r.rolname, current_database(), ''CREATE'') THEN ''CREATE,'' ELSE '''' END ||
                        CASE WHEN has_database_privilege(r.rolname, current_database(), ''TEMP'') THEN ''TEMP,'' ELSE '''' END ||
                        CASE WHEN has_database_privilege(r.rolname, current_database(), ''CONNECT'') THEN ''CONNECT'' ELSE '''' END
                    ), '',''))::TEXT AS privilege,
                ir.inherited_role,
                ''actual_database_privilege''::TEXT AS source
            FROM pg_roles r
            LEFT JOIN inherited_roles ir ON r.rolname = ir.role_name
        ),
        -- CTE to extract raw ACL entries from pg_default_acl for PG 14+
        raw_acls AS (
            SELECT
                pda.defaclnamespace::regnamespace::TEXT AS object_scope,
                (regexp_matches(acl_entry::TEXT, ''^(.+?)=([a-zA-Z]*)/?(.+)?$''))[1]::TEXT AS grantee,
                (regexp_matches(acl_entry::TEXT, ''^(.+?)=([a-zA-Z]*)/?(.+)?$''))[2]::TEXT AS privs_raw
            FROM pg_default_acl pda, unnest(pda.defaclacl) AS acl_entry
            WHERE current_setting(''server_version_num'')::INT >= 140000
        ),
        -- CTE to expand raw ACL characters into full privilege names
        expanded_acls AS (
            SELECT
                ra.object_scope,
                ra.grantee,
                CASE
                    WHEN ra.privs_raw IS NULL THEN NULL
                    ELSE array_to_string(ARRAY(
                        SELECT priv_subquery.privilege FROM (
                            SELECT CASE WHEN ra.privs_raw LIKE ''%a%'' THEN ''INSERT'' END AS privilege
                            UNION ALL SELECT CASE WHEN ra.privs_raw LIKE ''%r%'' THEN ''SELECT'' END
                            UNION ALL SELECT CASE WHEN ra.privs_raw LIKE ''%w%'' THEN ''UPDATE'' END
                            UNION ALL SELECT CASE WHEN ra.privs_raw LIKE ''%d%'' THEN ''DELETE'' END
                            UNION ALL SELECT CASE WHEN ra.privs_raw LIKE ''%D%'' THEN ''TRUNCATE'' END
                            UNION ALL SELECT CASE WHEN ra.privs_raw LIKE ''%x%'' THEN ''REFERENCES'' END
                            UNION ALL SELECT CASE WHEN ra.privs_raw LIKE ''%t%'' THEN ''TRIGGER'' END
                            UNION ALL SELECT CASE WHEN ra.privs_raw LIKE ''%X%'' THEN ''EXECUTE'' END
                        ) AS priv_subquery WHERE priv_subquery.privilege IS NOT NULL ORDER BY priv_subquery.privilege
                    ), '','')
                END AS privilege,
                ir.inherited_role,
                ''default_acl''::TEXT AS source
            FROM raw_acls ra
            LEFT JOIN inherited_roles ir ON ra.grantee = ir.role_name
        )

        -- Combine all privilege types and filter by p_role if provided
        SELECT sc.object_scope, sc.grantee, sc.privilege, sc.inherited_role, sc.source FROM schema_create sc WHERE p_role = '''' OR sc.grantee = p_role
        UNION ALL
        SELECT su.object_scope, su.grantee, su.privilege, su.inherited_role, su.source FROM schema_usage su WHERE p_role = '''' OR su.grantee = p_role
        UNION ALL
        SELECT db.object_scope, db.grantee, db.privilege, db.inherited_role, db.source FROM db_privs db WHERE p_role = '''' OR db.grantee = p_role
        UNION ALL
        SELECT ea.object_scope, ea.grantee, ea.privilege, ea.inherited_role, ea.source FROM expanded_acls ea WHERE p_role = '''' OR ea.grantee = p_role
        ORDER BY grantee, object_scope, privilege;
    END;
    $func$;
    ';

    -- Execute the dynamically constructed SQL to create the function
    EXECUTE v_sql;
END $$;
--- END FAILED SCRIPT ---
üîÅ Running on Kineteco_Restored...
üìÑ [Kineteco_Restored] /c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/5 other/dba.GetPrivileges.sql
üîó Running: psql -U "jrussell" -h "psqltstawrd01.clm0vrvchewi.us-east-2.rds.amazonaws.com" -p "5432" -d "Kineteco_Restored" -f "/c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/5 other/dba.GetPrivileges.sql"
psql: error: connection to server at "psqltstawrd01.clm0vrvchewi.us-east-2.rds.amazonaws.com" (172.31.26.43), port 5432 failed: FATAL:  database "Kineteco_Restored" does not exist
‚ùå ERROR running /c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/5 other/dba.GetPrivileges.sql against Kineteco_Restored
--- FAILED COMMAND ---
psql -U "jrussell" -h "psqltstawrd01.clm0vrvchewi.us-east-2.rds.amazonaws.com" -p "5432" -d "Kineteco_Restored" -f "/c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/5 other/dba.GetPrivileges.sql"
--- BEGIN FAILED SCRIPT: /c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/5 other/dba.GetPrivileges.sql ---
-- ============================================
-- Function: dynamic schema.GetPrivileges(p_role TEXT DEFAULT '')
-- Purpose: Retrieve role privileges across schemas and database
-- Version-safe: Includes default ACL parsing only if PG >= 140000
-- ============================================
set role dba_team; 

DO $$
DECLARE
    v_sql TEXT;
    v_schema TEXT;
    v_version INT := current_setting('server_version_num')::INT;
BEGIN
    -- Determine the schema for the function based on the current database
    IF current_database() = 'DBA' THEN
        v_schema := 'info';
    ELSIF current_database() IN ('postgres', 'rdsadmin') THEN
        RAISE NOTICE 'Skipping function creation in system DB: %', current_database();
        RETURN; -- Exit if in a system database
    ELSE
        v_schema := 'dba';
    END IF;

    -- Construct the dynamic SQL for creating or replacing the function
    v_sql := '
    CREATE OR REPLACE FUNCTION ' || quote_ident(v_schema) || '.GetPrivileges(p_role TEXT DEFAULT '''')
    RETURNS TABLE (
        object_scope TEXT,
        grantee TEXT,
        privilege TEXT,
        inherited_role TEXT,
        source TEXT
    )
    LANGUAGE plpgsql AS
    $func$
    DECLARE
        v_ver INT := current_setting(''server_version_num'')::INT;
    BEGIN
        RETURN QUERY
        -- CTE to get roles and their directly inherited roles
        WITH inherited_roles AS (
            SELECT
                r.rolname AS role_name,
                string_agg(m.rolname, '','' ORDER BY m.rolname) AS inherited_role
            FROM pg_roles r
            LEFT JOIN pg_auth_members am ON r.oid = am.member
            LEFT JOIN pg_roles m ON am.roleid = m.oid
            GROUP BY r.rolname
        ),
        -- CTE for schema CREATE privileges
        schema_create AS (
            SELECT
                n.nspname::TEXT AS object_scope,
                r.rolname::TEXT AS grantee,
                ''CREATE''::TEXT AS privilege,
                ir.inherited_role,
                ''actual_schema_privilege''::TEXT AS source
            FROM pg_namespace n
            JOIN pg_roles r ON has_schema_privilege(r.rolname, n.oid, ''CREATE'')
            LEFT JOIN inherited_roles ir ON r.rolname = ir.role_name
            WHERE n.nspname NOT LIKE ''pg_%'' AND n.nspname <> ''information_schema''
        ),
        -- CTE for schema USAGE privileges
        schema_usage AS (
            SELECT
                n.nspname::TEXT AS object_scope,
                r.rolname::TEXT AS grantee,
                ''USAGE''::TEXT AS privilege,
                ir.inherited_role,
                ''actual_schema_privilege''::TEXT AS source
            FROM pg_namespace n
            JOIN pg_roles r ON has_schema_privilege(r.rolname, n.oid, ''USAGE'')
            LEFT JOIN inherited_roles ir ON r.rolname = ir.role_name
            WHERE n.nspname NOT LIKE ''pg_%'' AND n.nspname <> ''information_schema''
        ),
        -- CTE for database-level privileges (CREATE, TEMP, CONNECT)
        db_privs AS (
            SELECT
                current_database()::TEXT AS object_scope,
                r.rolname::TEXT AS grantee,
                unnest(string_to_array(
                    TRIM(BOTH '','' FROM
                        CASE WHEN has_database_privilege(r.rolname, current_database(), ''CREATE'') THEN ''CREATE,'' ELSE '''' END ||
                        CASE WHEN has_database_privilege(r.rolname, current_database(), ''TEMP'') THEN ''TEMP,'' ELSE '''' END ||
                        CASE WHEN has_database_privilege(r.rolname, current_database(), ''CONNECT'') THEN ''CONNECT'' ELSE '''' END
                    ), '',''))::TEXT AS privilege,
                ir.inherited_role,
                ''actual_database_privilege''::TEXT AS source
            FROM pg_roles r
            LEFT JOIN inherited_roles ir ON r.rolname = ir.role_name
        ),
        -- CTE to extract raw ACL entries from pg_default_acl for PG 14+
        raw_acls AS (
            SELECT
                pda.defaclnamespace::regnamespace::TEXT AS object_scope,
                (regexp_matches(acl_entry::TEXT, ''^(.+?)=([a-zA-Z]*)/?(.+)?$''))[1]::TEXT AS grantee,
                (regexp_matches(acl_entry::TEXT, ''^(.+?)=([a-zA-Z]*)/?(.+)?$''))[2]::TEXT AS privs_raw
            FROM pg_default_acl pda, unnest(pda.defaclacl) AS acl_entry
            WHERE current_setting(''server_version_num'')::INT >= 140000
        ),
        -- CTE to expand raw ACL characters into full privilege names
        expanded_acls AS (
            SELECT
                ra.object_scope,
                ra.grantee,
                CASE
                    WHEN ra.privs_raw IS NULL THEN NULL
                    ELSE array_to_string(ARRAY(
                        SELECT priv_subquery.privilege FROM (
                            SELECT CASE WHEN ra.privs_raw LIKE ''%a%'' THEN ''INSERT'' END AS privilege
                            UNION ALL SELECT CASE WHEN ra.privs_raw LIKE ''%r%'' THEN ''SELECT'' END
                            UNION ALL SELECT CASE WHEN ra.privs_raw LIKE ''%w%'' THEN ''UPDATE'' END
                            UNION ALL SELECT CASE WHEN ra.privs_raw LIKE ''%d%'' THEN ''DELETE'' END
                            UNION ALL SELECT CASE WHEN ra.privs_raw LIKE ''%D%'' THEN ''TRUNCATE'' END
                            UNION ALL SELECT CASE WHEN ra.privs_raw LIKE ''%x%'' THEN ''REFERENCES'' END
                            UNION ALL SELECT CASE WHEN ra.privs_raw LIKE ''%t%'' THEN ''TRIGGER'' END
                            UNION ALL SELECT CASE WHEN ra.privs_raw LIKE ''%X%'' THEN ''EXECUTE'' END
                        ) AS priv_subquery WHERE priv_subquery.privilege IS NOT NULL ORDER BY priv_subquery.privilege
                    ), '','')
                END AS privilege,
                ir.inherited_role,
                ''default_acl''::TEXT AS source
            FROM raw_acls ra
            LEFT JOIN inherited_roles ir ON ra.grantee = ir.role_name
        )

        -- Combine all privilege types and filter by p_role if provided
        SELECT sc.object_scope, sc.grantee, sc.privilege, sc.inherited_role, sc.source FROM schema_create sc WHERE p_role = '''' OR sc.grantee = p_role
        UNION ALL
        SELECT su.object_scope, su.grantee, su.privilege, su.inherited_role, su.source FROM schema_usage su WHERE p_role = '''' OR su.grantee = p_role
        UNION ALL
        SELECT db.object_scope, db.grantee, db.privilege, db.inherited_role, db.source FROM db_privs db WHERE p_role = '''' OR db.grantee = p_role
        UNION ALL
        SELECT ea.object_scope, ea.grantee, ea.privilege, ea.inherited_role, ea.source FROM expanded_acls ea WHERE p_role = '''' OR ea.grantee = p_role
        ORDER BY grantee, object_scope, privilege;
    END;
    $func$;
    ';

    -- Execute the dynamically constructed SQL to create the function
    EXECUTE v_sql;
END $$;
--- END FAILED SCRIPT ---
üîÅ Running on MiddleEarth...
üìÑ [MiddleEarth] /c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/5 other/dba.GetPrivileges.sql
üîó Running: psql -U "jrussell" -h "psqltstawrd01.clm0vrvchewi.us-east-2.rds.amazonaws.com" -p "5432" -d "MiddleEarth" -f "/c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/5 other/dba.GetPrivileges.sql"
psql: error: connection to server at "psqltstawrd01.clm0vrvchewi.us-east-2.rds.amazonaws.com" (172.31.26.43), port 5432 failed: FATAL:  database "MiddleEarth" does not exist
‚ùå ERROR running /c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/5 other/dba.GetPrivileges.sql against MiddleEarth
--- FAILED COMMAND ---
psql -U "jrussell" -h "psqltstawrd01.clm0vrvchewi.us-east-2.rds.amazonaws.com" -p "5432" -d "MiddleEarth" -f "/c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/5 other/dba.GetPrivileges.sql"
--- BEGIN FAILED SCRIPT: /c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/5 other/dba.GetPrivileges.sql ---
-- ============================================
-- Function: dynamic schema.GetPrivileges(p_role TEXT DEFAULT '')
-- Purpose: Retrieve role privileges across schemas and database
-- Version-safe: Includes default ACL parsing only if PG >= 140000
-- ============================================
set role dba_team; 

DO $$
DECLARE
    v_sql TEXT;
    v_schema TEXT;
    v_version INT := current_setting('server_version_num')::INT;
BEGIN
    -- Determine the schema for the function based on the current database
    IF current_database() = 'DBA' THEN
        v_schema := 'info';
    ELSIF current_database() IN ('postgres', 'rdsadmin') THEN
        RAISE NOTICE 'Skipping function creation in system DB: %', current_database();
        RETURN; -- Exit if in a system database
    ELSE
        v_schema := 'dba';
    END IF;

    -- Construct the dynamic SQL for creating or replacing the function
    v_sql := '
    CREATE OR REPLACE FUNCTION ' || quote_ident(v_schema) || '.GetPrivileges(p_role TEXT DEFAULT '''')
    RETURNS TABLE (
        object_scope TEXT,
        grantee TEXT,
        privilege TEXT,
        inherited_role TEXT,
        source TEXT
    )
    LANGUAGE plpgsql AS
    $func$
    DECLARE
        v_ver INT := current_setting(''server_version_num'')::INT;
    BEGIN
        RETURN QUERY
        -- CTE to get roles and their directly inherited roles
        WITH inherited_roles AS (
            SELECT
                r.rolname AS role_name,
                string_agg(m.rolname, '','' ORDER BY m.rolname) AS inherited_role
            FROM pg_roles r
            LEFT JOIN pg_auth_members am ON r.oid = am.member
            LEFT JOIN pg_roles m ON am.roleid = m.oid
            GROUP BY r.rolname
        ),
        -- CTE for schema CREATE privileges
        schema_create AS (
            SELECT
                n.nspname::TEXT AS object_scope,
                r.rolname::TEXT AS grantee,
                ''CREATE''::TEXT AS privilege,
                ir.inherited_role,
                ''actual_schema_privilege''::TEXT AS source
            FROM pg_namespace n
            JOIN pg_roles r ON has_schema_privilege(r.rolname, n.oid, ''CREATE'')
            LEFT JOIN inherited_roles ir ON r.rolname = ir.role_name
            WHERE n.nspname NOT LIKE ''pg_%'' AND n.nspname <> ''information_schema''
        ),
        -- CTE for schema USAGE privileges
        schema_usage AS (
            SELECT
                n.nspname::TEXT AS object_scope,
                r.rolname::TEXT AS grantee,
                ''USAGE''::TEXT AS privilege,
                ir.inherited_role,
                ''actual_schema_privilege''::TEXT AS source
            FROM pg_namespace n
            JOIN pg_roles r ON has_schema_privilege(r.rolname, n.oid, ''USAGE'')
            LEFT JOIN inherited_roles ir ON r.rolname = ir.role_name
            WHERE n.nspname NOT LIKE ''pg_%'' AND n.nspname <> ''information_schema''
        ),
        -- CTE for database-level privileges (CREATE, TEMP, CONNECT)
        db_privs AS (
            SELECT
                current_database()::TEXT AS object_scope,
                r.rolname::TEXT AS grantee,
                unnest(string_to_array(
                    TRIM(BOTH '','' FROM
                        CASE WHEN has_database_privilege(r.rolname, current_database(), ''CREATE'') THEN ''CREATE,'' ELSE '''' END ||
                        CASE WHEN has_database_privilege(r.rolname, current_database(), ''TEMP'') THEN ''TEMP,'' ELSE '''' END ||
                        CASE WHEN has_database_privilege(r.rolname, current_database(), ''CONNECT'') THEN ''CONNECT'' ELSE '''' END
                    ), '',''))::TEXT AS privilege,
                ir.inherited_role,
                ''actual_database_privilege''::TEXT AS source
            FROM pg_roles r
            LEFT JOIN inherited_roles ir ON r.rolname = ir.role_name
        ),
        -- CTE to extract raw ACL entries from pg_default_acl for PG 14+
        raw_acls AS (
            SELECT
                pda.defaclnamespace::regnamespace::TEXT AS object_scope,
                (regexp_matches(acl_entry::TEXT, ''^(.+?)=([a-zA-Z]*)/?(.+)?$''))[1]::TEXT AS grantee,
                (regexp_matches(acl_entry::TEXT, ''^(.+?)=([a-zA-Z]*)/?(.+)?$''))[2]::TEXT AS privs_raw
            FROM pg_default_acl pda, unnest(pda.defaclacl) AS acl_entry
            WHERE current_setting(''server_version_num'')::INT >= 140000
        ),
        -- CTE to expand raw ACL characters into full privilege names
        expanded_acls AS (
            SELECT
                ra.object_scope,
                ra.grantee,
                CASE
                    WHEN ra.privs_raw IS NULL THEN NULL
                    ELSE array_to_string(ARRAY(
                        SELECT priv_subquery.privilege FROM (
                            SELECT CASE WHEN ra.privs_raw LIKE ''%a%'' THEN ''INSERT'' END AS privilege
                            UNION ALL SELECT CASE WHEN ra.privs_raw LIKE ''%r%'' THEN ''SELECT'' END
                            UNION ALL SELECT CASE WHEN ra.privs_raw LIKE ''%w%'' THEN ''UPDATE'' END
                            UNION ALL SELECT CASE WHEN ra.privs_raw LIKE ''%d%'' THEN ''DELETE'' END
                            UNION ALL SELECT CASE WHEN ra.privs_raw LIKE ''%D%'' THEN ''TRUNCATE'' END
                            UNION ALL SELECT CASE WHEN ra.privs_raw LIKE ''%x%'' THEN ''REFERENCES'' END
                            UNION ALL SELECT CASE WHEN ra.privs_raw LIKE ''%t%'' THEN ''TRIGGER'' END
                            UNION ALL SELECT CASE WHEN ra.privs_raw LIKE ''%X%'' THEN ''EXECUTE'' END
                        ) AS priv_subquery WHERE priv_subquery.privilege IS NOT NULL ORDER BY priv_subquery.privilege
                    ), '','')
                END AS privilege,
                ir.inherited_role,
                ''default_acl''::TEXT AS source
            FROM raw_acls ra
            LEFT JOIN inherited_roles ir ON ra.grantee = ir.role_name
        )

        -- Combine all privilege types and filter by p_role if provided
        SELECT sc.object_scope, sc.grantee, sc.privilege, sc.inherited_role, sc.source FROM schema_create sc WHERE p_role = '''' OR sc.grantee = p_role
        UNION ALL
        SELECT su.object_scope, su.grantee, su.privilege, su.inherited_role, su.source FROM schema_usage su WHERE p_role = '''' OR su.grantee = p_role
        UNION ALL
        SELECT db.object_scope, db.grantee, db.privilege, db.inherited_role, db.source FROM db_privs db WHERE p_role = '''' OR db.grantee = p_role
        UNION ALL
        SELECT ea.object_scope, ea.grantee, ea.privilege, ea.inherited_role, ea.source FROM expanded_acls ea WHERE p_role = '''' OR ea.grantee = p_role
        ORDER BY grantee, object_scope, privilege;
    END;
    $func$;
    ';

    -- Execute the dynamically constructed SQL to create the function
    EXECUTE v_sql;
END $$;
--- END FAILED SCRIPT ---
üîÅ Running on DBA_HKB...
üìÑ [DBA_HKB] /c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/5 other/dba.GetPrivileges.sql
üîó Running: psql -U "jrussell" -h "psqltstawrd01.clm0vrvchewi.us-east-2.rds.amazonaws.com" -p "5432" -d "DBA_HKB" -f "/c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/5 other/dba.GetPrivileges.sql"
psql: error: connection to server at "psqltstawrd01.clm0vrvchewi.us-east-2.rds.amazonaws.com" (172.31.26.43), port 5432 failed: FATAL:  database "DBA_HKB" does not exist
‚ùå ERROR running /c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/5 other/dba.GetPrivileges.sql against DBA_HKB
--- FAILED COMMAND ---
psql -U "jrussell" -h "psqltstawrd01.clm0vrvchewi.us-east-2.rds.amazonaws.com" -p "5432" -d "DBA_HKB" -f "/c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/5 other/dba.GetPrivileges.sql"
--- BEGIN FAILED SCRIPT: /c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/5 other/dba.GetPrivileges.sql ---
-- ============================================
-- Function: dynamic schema.GetPrivileges(p_role TEXT DEFAULT '')
-- Purpose: Retrieve role privileges across schemas and database
-- Version-safe: Includes default ACL parsing only if PG >= 140000
-- ============================================
set role dba_team; 

DO $$
DECLARE
    v_sql TEXT;
    v_schema TEXT;
    v_version INT := current_setting('server_version_num')::INT;
BEGIN
    -- Determine the schema for the function based on the current database
    IF current_database() = 'DBA' THEN
        v_schema := 'info';
    ELSIF current_database() IN ('postgres', 'rdsadmin') THEN
        RAISE NOTICE 'Skipping function creation in system DB: %', current_database();
        RETURN; -- Exit if in a system database
    ELSE
        v_schema := 'dba';
    END IF;

    -- Construct the dynamic SQL for creating or replacing the function
    v_sql := '
    CREATE OR REPLACE FUNCTION ' || quote_ident(v_schema) || '.GetPrivileges(p_role TEXT DEFAULT '''')
    RETURNS TABLE (
        object_scope TEXT,
        grantee TEXT,
        privilege TEXT,
        inherited_role TEXT,
        source TEXT
    )
    LANGUAGE plpgsql AS
    $func$
    DECLARE
        v_ver INT := current_setting(''server_version_num'')::INT;
    BEGIN
        RETURN QUERY
        -- CTE to get roles and their directly inherited roles
        WITH inherited_roles AS (
            SELECT
                r.rolname AS role_name,
                string_agg(m.rolname, '','' ORDER BY m.rolname) AS inherited_role
            FROM pg_roles r
            LEFT JOIN pg_auth_members am ON r.oid = am.member
            LEFT JOIN pg_roles m ON am.roleid = m.oid
            GROUP BY r.rolname
        ),
        -- CTE for schema CREATE privileges
        schema_create AS (
            SELECT
                n.nspname::TEXT AS object_scope,
                r.rolname::TEXT AS grantee,
                ''CREATE''::TEXT AS privilege,
                ir.inherited_role,
                ''actual_schema_privilege''::TEXT AS source
            FROM pg_namespace n
            JOIN pg_roles r ON has_schema_privilege(r.rolname, n.oid, ''CREATE'')
            LEFT JOIN inherited_roles ir ON r.rolname = ir.role_name
            WHERE n.nspname NOT LIKE ''pg_%'' AND n.nspname <> ''information_schema''
        ),
        -- CTE for schema USAGE privileges
        schema_usage AS (
            SELECT
                n.nspname::TEXT AS object_scope,
                r.rolname::TEXT AS grantee,
                ''USAGE''::TEXT AS privilege,
                ir.inherited_role,
                ''actual_schema_privilege''::TEXT AS source
            FROM pg_namespace n
            JOIN pg_roles r ON has_schema_privilege(r.rolname, n.oid, ''USAGE'')
            LEFT JOIN inherited_roles ir ON r.rolname = ir.role_name
            WHERE n.nspname NOT LIKE ''pg_%'' AND n.nspname <> ''information_schema''
        ),
        -- CTE for database-level privileges (CREATE, TEMP, CONNECT)
        db_privs AS (
            SELECT
                current_database()::TEXT AS object_scope,
                r.rolname::TEXT AS grantee,
                unnest(string_to_array(
                    TRIM(BOTH '','' FROM
                        CASE WHEN has_database_privilege(r.rolname, current_database(), ''CREATE'') THEN ''CREATE,'' ELSE '''' END ||
                        CASE WHEN has_database_privilege(r.rolname, current_database(), ''TEMP'') THEN ''TEMP,'' ELSE '''' END ||
                        CASE WHEN has_database_privilege(r.rolname, current_database(), ''CONNECT'') THEN ''CONNECT'' ELSE '''' END
                    ), '',''))::TEXT AS privilege,
                ir.inherited_role,
                ''actual_database_privilege''::TEXT AS source
            FROM pg_roles r
            LEFT JOIN inherited_roles ir ON r.rolname = ir.role_name
        ),
        -- CTE to extract raw ACL entries from pg_default_acl for PG 14+
        raw_acls AS (
            SELECT
                pda.defaclnamespace::regnamespace::TEXT AS object_scope,
                (regexp_matches(acl_entry::TEXT, ''^(.+?)=([a-zA-Z]*)/?(.+)?$''))[1]::TEXT AS grantee,
                (regexp_matches(acl_entry::TEXT, ''^(.+?)=([a-zA-Z]*)/?(.+)?$''))[2]::TEXT AS privs_raw
            FROM pg_default_acl pda, unnest(pda.defaclacl) AS acl_entry
            WHERE current_setting(''server_version_num'')::INT >= 140000
        ),
        -- CTE to expand raw ACL characters into full privilege names
        expanded_acls AS (
            SELECT
                ra.object_scope,
                ra.grantee,
                CASE
                    WHEN ra.privs_raw IS NULL THEN NULL
                    ELSE array_to_string(ARRAY(
                        SELECT priv_subquery.privilege FROM (
                            SELECT CASE WHEN ra.privs_raw LIKE ''%a%'' THEN ''INSERT'' END AS privilege
                            UNION ALL SELECT CASE WHEN ra.privs_raw LIKE ''%r%'' THEN ''SELECT'' END
                            UNION ALL SELECT CASE WHEN ra.privs_raw LIKE ''%w%'' THEN ''UPDATE'' END
                            UNION ALL SELECT CASE WHEN ra.privs_raw LIKE ''%d%'' THEN ''DELETE'' END
                            UNION ALL SELECT CASE WHEN ra.privs_raw LIKE ''%D%'' THEN ''TRUNCATE'' END
                            UNION ALL SELECT CASE WHEN ra.privs_raw LIKE ''%x%'' THEN ''REFERENCES'' END
                            UNION ALL SELECT CASE WHEN ra.privs_raw LIKE ''%t%'' THEN ''TRIGGER'' END
                            UNION ALL SELECT CASE WHEN ra.privs_raw LIKE ''%X%'' THEN ''EXECUTE'' END
                        ) AS priv_subquery WHERE priv_subquery.privilege IS NOT NULL ORDER BY priv_subquery.privilege
                    ), '','')
                END AS privilege,
                ir.inherited_role,
                ''default_acl''::TEXT AS source
            FROM raw_acls ra
            LEFT JOIN inherited_roles ir ON ra.grantee = ir.role_name
        )

        -- Combine all privilege types and filter by p_role if provided
        SELECT sc.object_scope, sc.grantee, sc.privilege, sc.inherited_role, sc.source FROM schema_create sc WHERE p_role = '''' OR sc.grantee = p_role
        UNION ALL
        SELECT su.object_scope, su.grantee, su.privilege, su.inherited_role, su.source FROM schema_usage su WHERE p_role = '''' OR su.grantee = p_role
        UNION ALL
        SELECT db.object_scope, db.grantee, db.privilege, db.inherited_role, db.source FROM db_privs db WHERE p_role = '''' OR db.grantee = p_role
        UNION ALL
        SELECT ea.object_scope, ea.grantee, ea.privilege, ea.inherited_role, ea.source FROM expanded_acls ea WHERE p_role = '''' OR ea.grantee = p_role
        ORDER BY grantee, object_scope, privilege;
    END;
    $func$;
    ';

    -- Execute the dynamically constructed SQL to create the function
    EXECUTE v_sql;
END $$;
--- END FAILED SCRIPT ---
üîÅ Running on DB_AC...
üìÑ [DB_AC] /c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/5 other/dba.GetPrivileges.sql
üîó Running: psql -U "jrussell" -h "psqltstawrd01.clm0vrvchewi.us-east-2.rds.amazonaws.com" -p "5432" -d "DB_AC" -f "/c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/5 other/dba.GetPrivileges.sql"
SET
psql:C:/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/5 other/dba.GetPrivileges.sql:142: ERROR:  schema "dba" does not exist
CONTEXT:  SQL statement "
    CREATE OR REPLACE FUNCTION dba.GetPrivileges(p_role TEXT DEFAULT '')
    RETURNS TABLE (
        object_scope TEXT,
        grantee TEXT,
        privilege TEXT,
        inherited_role TEXT,
        source TEXT
    )
    LANGUAGE plpgsql AS
    $func$
    DECLARE
        v_ver INT := current_setting('server_version_num')::INT;
    BEGIN
        RETURN QUERY
        -- CTE to get roles and their directly inherited roles
        WITH inherited_roles AS (
            SELECT
                r.rolname AS role_name,
                string_agg(m.rolname, ',' ORDER BY m.rolname) AS inherited_role
            FROM pg_roles r
            LEFT JOIN pg_auth_members am ON r.oid = am.member
            LEFT JOIN pg_roles m ON am.roleid = m.oid
            GROUP BY r.rolname
        ),
        -- CTE for schema CREATE privileges
        schema_create AS (
            SELECT
                n.nspname::TEXT AS object_scope,
                r.rolname::TEXT AS grantee,
                'CREATE'::TEXT AS privilege,
                ir.inherited_role,
                'actual_schema_privilege'::TEXT AS source
            FROM pg_namespace n
            JOIN pg_roles r ON has_schema_privilege(r.rolname, n.oid, 'CREATE')
            LEFT JOIN inherited_roles ir ON r.rolname = ir.role_name
            WHERE n.nspname NOT LIKE 'pg_%' AND n.nspname <> 'information_schema'
        ),
        -- CTE for schema USAGE privileges
        schema_usage AS (
            SELECT
                n.nspname::TEXT AS object_scope,
                r.rolname::TEXT AS grantee,
                'USAGE'::TEXT AS privilege,
                ir.inherited_role,
                'actual_schema_privilege'::TEXT AS source
            FROM pg_namespace n
            JOIN pg_roles r ON has_schema_privilege(r.rolname, n.oid, 'USAGE')
            LEFT JOIN inherited_roles ir ON r.rolname = ir.role_name
            WHERE n.nspname NOT LIKE 'pg_%' AND n.nspname <> 'information_schema'
        ),
        -- CTE for database-level privileges (CREATE, TEMP, CONNECT)
        db_privs AS (
            SELECT
                current_database()::TEXT AS object_scope,
                r.rolname::TEXT AS grantee,
                unnest(string_to_array(
                    TRIM(BOTH ',' FROM
                        CASE WHEN has_database_privilege(r.rolname, current_database(), 'CREATE') THEN 'CREATE,' ELSE '' END ||
                        CASE WHEN has_database_privilege(r.rolname, current_database(), 'TEMP') THEN 'TEMP,' ELSE '' END ||
                        CASE WHEN has_database_privilege(r.rolname, current_database(), 'CONNECT') THEN 'CONNECT' ELSE '' END
                    ), ','))::TEXT AS privilege,
                ir.inherited_role,
                'actual_database_privilege'::TEXT AS source
            FROM pg_roles r
            LEFT JOIN inherited_roles ir ON r.rolname = ir.role_name
        ),
        -- CTE to extract raw ACL entries from pg_default_acl for PG 14+
        raw_acls AS (
            SELECT
                pda.defaclnamespace::regnamespace::TEXT AS object_scope,
                (regexp_matches(acl_entry::TEXT, '^(.+?)=([a-zA-Z]*)/?(.+)?$'))[1]::TEXT AS grantee,
                (regexp_matches(acl_entry::TEXT, '^(.+?)=([a-zA-Z]*)/?(.+)?$'))[2]::TEXT AS privs_raw
            FROM pg_default_acl pda, unnest(pda.defaclacl) AS acl_entry
            WHERE current_setting('server_version_num')::INT >= 140000
        ),
        -- CTE to expand raw ACL characters into full privilege names
        expanded_acls AS (
            SELECT
                ra.object_scope,
                ra.grantee,
                CASE
                    WHEN ra.privs_raw IS NULL THEN NULL
                    ELSE array_to_string(ARRAY(
                        SELECT priv_subquery.privilege FROM (
                            SELECT CASE WHEN ra.privs_raw LIKE '%a%' THEN 'INSERT' END AS privilege
                            UNION ALL SELECT CASE WHEN ra.privs_raw LIKE '%r%' THEN 'SELECT' END
                            UNION ALL SELECT CASE WHEN ra.privs_raw LIKE '%w%' THEN 'UPDATE' END
                            UNION ALL SELECT CASE WHEN ra.privs_raw LIKE '%d%' THEN 'DELETE' END
                            UNION ALL SELECT CASE WHEN ra.privs_raw LIKE '%D%' THEN 'TRUNCATE' END
                            UNION ALL SELECT CASE WHEN ra.privs_raw LIKE '%x%' THEN 'REFERENCES' END
                            UNION ALL SELECT CASE WHEN ra.privs_raw LIKE '%t%' THEN 'TRIGGER' END
                            UNION ALL SELECT CASE WHEN ra.privs_raw LIKE '%X%' THEN 'EXECUTE' END
                        ) AS priv_subquery WHERE priv_subquery.privilege IS NOT NULL ORDER BY priv_subquery.privilege
                    ), ',')
                END AS privilege,
                ir.inherited_role,
                'default_acl'::TEXT AS source
            FROM raw_acls ra
            LEFT JOIN inherited_roles ir ON ra.grantee = ir.role_name
        )

        -- Combine all privilege types and filter by p_role if provided
        SELECT sc.object_scope, sc.grantee, sc.privilege, sc.inherited_role, sc.source FROM schema_create sc WHERE p_role = '' OR sc.grantee = p_role
        UNION ALL
        SELECT su.object_scope, su.grantee, su.privilege, su.inherited_role, su.source FROM schema_usage su WHERE p_role = '' OR su.grantee = p_role
        UNION ALL
        SELECT db.object_scope, db.grantee, db.privilege, db.inherited_role, db.source FROM db_privs db WHERE p_role = '' OR db.grantee = p_role
        UNION ALL
        SELECT ea.object_scope, ea.grantee, ea.privilege, ea.inherited_role, ea.source FROM expanded_acls ea WHERE p_role = '' OR ea.grantee = p_role
        ORDER BY grantee, object_scope, privilege;
    END;
    $func$;
    "
PL/pgSQL function inline_code_block line 134 at EXECUTE
üöÄ Running on dba-exp-tst.cluster-clm0vrvchewi.us-east-2.rds.amazonaws.com...
=== dba-exp-tst.cluster-clm0vrvchewi.us-east-2.rds.amazonaws.com ===
‚úÖ DBA found. Executing against DBA...
üìÑ [DBA] /c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/1 initial/DBA_database_creation.sql
üîó Running: psql -U "jrussell" -h "dba-exp-tst.cluster-clm0vrvchewi.us-east-2.rds.amazonaws.com" -p "5432" -d DBA -f "/c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/1 initial/DBA_database_creation.sql"
psql: error: connection to server at "dba-exp-tst.cluster-clm0vrvchewi.us-east-2.rds.amazonaws.com" (172.31.24.19), port 5432 failed: FATAL:  database "DBA" does not exist
‚ùå ERROR running /c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/1 initial/DBA_database_creation.sql against DBA
--- FAILED COMMAND ---
psql -U "jrussell" -h "dba-exp-tst.cluster-clm0vrvchewi.us-east-2.rds.amazonaws.com" -p "5432" -d DBA -f "/c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/1 initial/DBA_database_creation.sql"
--- BEGIN FAILED SCRIPT: /c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/1 initial/DBA_database_creation.sql ---

-- ============================================
-- Script: DBA_database_creation.sql
-- Purpose: Create the 'DBA' database using template0
-- ============================================
set role dbadmin;

set role dbadmin;

-- Set default db name.
-- We now set the variable to a string that includes the double quotes.
\if :{?dbname}
    -- User provided a name, assume it's already quoted or correctly capitalized
    -- and we will pass it through.
    \echo Using user-provided database name: :dbname
\else
    -- Default to "DBA" by setting the variable to the quoted string.
    \set dbname '"DBA"'
    \echo Using default database name: :dbname
\endif


-- Confirm variable
\echo Final database name: :dbname

-- Use the variable directly. It already contains the necessary quotes.
CREATE DATABASE :dbname
    WITH OWNER = dbadmin
    TEMPLATE = template0
    ENCODING = 'UTF8'
    LC_COLLATE = 'en_US.UTF-8'
    LC_CTYPE = 'en_US.UTF-8'
    CONNECTION LIMIT = -1;


GRANT TEMPORARY, CONNECT ON DATABASE :dbname TO PUBLIC;

GRANT ALL ON DATABASE :dbname  TO dba_team WITH GRANT OPTION;

GRANT ALL ON DATABASE :dbname TO dbadmin;


GRANT CREATE ON DATABASE :dbname TO dba_team;--- END FAILED SCRIPT ---
üìÑ [DBA] /c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/1 initial/Schema_creation.sql
üîó Running: psql -U "jrussell" -h "dba-exp-tst.cluster-clm0vrvchewi.us-east-2.rds.amazonaws.com" -p "5432" -d DBA -f "/c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/1 initial/Schema_creation.sql"
psql: error: connection to server at "dba-exp-tst.cluster-clm0vrvchewi.us-east-2.rds.amazonaws.com" (172.31.24.19), port 5432 failed: FATAL:  database "DBA" does not exist
‚ùå ERROR running /c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/1 initial/Schema_creation.sql against DBA
--- FAILED COMMAND ---
psql -U "jrussell" -h "dba-exp-tst.cluster-clm0vrvchewi.us-east-2.rds.amazonaws.com" -p "5432" -d DBA -f "/c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/1 initial/Schema_creation.sql"
--- BEGIN FAILED SCRIPT: /c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/1 initial/Schema_creation.sql ---
-- ‚úÖ PostgreSQL-Compatible Schema Creation Script
-- Filename: 03_Schema_creation.sql

-- ============================================================
-- STEP 1: Create 'info' schema if not exists and grant privileges
-- ============================================================
set role dba_team; 

DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_namespace WHERE nspname = 'info') THEN
        EXECUTE 'CREATE SCHEMA info AUTHORIZATION dba_team';
        RAISE NOTICE 'Schema "info" created.';
    ELSE
        RAISE NOTICE 'Schema "info" already exists.';
    END IF;
END
$$;

-- Grant privileges on the 'info' schema
GRANT USAGE ON SCHEMA info TO db_datareader;
GRANT USAGE ON SCHEMA info TO db_datawriter;
GRANT USAGE ON SCHEMA info TO db_ddladmin;




GRANT SELECT ON ALL TABLES IN SCHEMA info TO db_datareader;
GRANT DELETE, INSERT, SELECT, UPDATE ON ALL TABLES IN SCHEMA info TO db_datawriter;
GRANT ALL ON ALL TABLES IN SCHEMA info TO db_ddladmin;

GRANT EXECUTE ON ALL FUNCTIONS IN SCHEMA info TO db_datareader;
GRANT EXECUTE ON ALL FUNCTIONS IN SCHEMA info TO db_datawriter;
GRANT EXECUTE ON ALL FUNCTIONS IN SCHEMA info TO db_ddladmin;

-- ============================================================
-- STEP 2: Create 'deploy' schema if not exists and grant privileges
-- ============================================================

DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_namespace WHERE nspname = 'deploy') THEN
        EXECUTE 'CREATE SCHEMA deploy AUTHORIZATION dba_team';
        RAISE NOTICE 'Schema "deploy" created.';
    ELSE
        RAISE NOTICE 'Schema "deploy" already exists.';
    END IF;
END
$$;

-- Grant privileges on the 'deploy' schema
GRANT USAGE ON SCHEMA deploy TO dba_team;
GRANT INSERT, SELECT, UPDATE ON ALL TABLES IN SCHEMA deploy TO dba_team;
GRANT EXECUTE ON ALL FUNCTIONS IN SCHEMA deploy TO dba_team;
REVOKE ALL ON SCHEMA deploy FROM PUBLIC;




CREATE SCHEMA IF NOT EXISTS admin AUTHORIZATION dba_team;


-- Grant access to expected roles
GRANT USAGE ON SCHEMA admin TO dba_team;
GRANT INSERT, SELECT, UPDATE ON ALL TABLES IN SCHEMA admin TO dba_team;
GRANT EXECUTE ON ALL FUNCTIONS IN SCHEMA admin TO dba_team;
REVOKE ALL ON SCHEMA admin FROM PUBLIC;

--- END FAILED SCRIPT ---
üìÑ [DBA] /c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/1 initial/Tablecreations.sql
üîó Running: psql -U "jrussell" -h "dba-exp-tst.cluster-clm0vrvchewi.us-east-2.rds.amazonaws.com" -p "5432" -d DBA -f "/c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/1 initial/Tablecreations.sql"
psql: error: connection to server at "dba-exp-tst.cluster-clm0vrvchewi.us-east-2.rds.amazonaws.com" (172.31.24.19), port 5432 failed: FATAL:  database "DBA" does not exist
‚ùå ERROR running /c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/1 initial/Tablecreations.sql against DBA
--- FAILED COMMAND ---
psql -U "jrussell" -h "dba-exp-tst.cluster-clm0vrvchewi.us-east-2.rds.amazonaws.com" -p "5432" -d DBA -f "/c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/1 initial/Tablecreations.sql"
--- BEGIN FAILED SCRIPT: /c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/1 initial/Tablecreations.sql ---
-- ‚úÖ PostgreSQL-Compatible Audit Log Table Creation
-- Filename: 04_tablecreations.sql

-- ================================================================
-- Create: info.account_log_history with auto-incrementing log_id
-- ================================================================
set role dba_team; 

DO $$
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.tables 
        WHERE table_schema = 'info' AND table_name = 'account_log_history'
    ) THEN
        EXECUTE '
CREATE SEQUENCE IF NOT EXISTS info.account_log_history_log_id_seq
    START WITH 1
    INCREMENT BY 1;

CREATE TABLE IF NOT EXISTS info.account_log_history (
    log_id INTEGER NOT NULL DEFAULT nextval(''info.account_log_history_log_id_seq''),
    log_timestamp TIMESTAMPTZ DEFAULT now(),
    action_type TEXT COLLATE pg_catalog."default" NOT NULL,
    target_entity TEXT COLLATE pg_catalog."default" NOT NULL,
    associated_entity TEXT COLLATE pg_catalog."default",
    status TEXT COLLATE pg_catalog."default" NOT NULL,
    sql_command TEXT COLLATE pg_catalog."default",
    message TEXT COLLATE pg_catalog."default",
    CONSTRAINT account_log_history_pkey PRIMARY KEY (log_id)
)
TABLESPACE pg_default;

ALTER SEQUENCE info.account_log_history_log_id_seq
OWNED BY info.account_log_history.log_id;

ALTER TABLE IF EXISTS info.account_log_history
    OWNER TO dba_team;

GRANT SELECT ON TABLE info.account_log_history TO db_datareader;
GRANT ALL ON TABLE info.account_log_history TO db_ddladmin;
GRANT ALL ON TABLE info.account_log_history TO dba_team;
        ';
        RAISE NOTICE 'Table "info.account_log_history" created.';
    ELSE
        RAISE NOTICE 'Table "info.account_log_history" already exists.';
    END IF;
END
$$;

-- ================================================================
-- Create: info.object_log_history
-- ================================================================

DO $$
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.tables 
        WHERE table_schema = 'info' AND table_name = 'object_log_history'
    ) THEN
        EXECUTE '
CREATE TABLE IF NOT EXISTS info.object_log_history (
    log_id SERIAL PRIMARY KEY,
    log_timestamp TIMESTAMPTZ DEFAULT now(),
    action_type TEXT NOT NULL,
    target_entity TEXT NOT NULL,
    associated_entity TEXT,
    status TEXT NOT NULL,
    sql_command TEXT,
    message TEXT
);

ALTER TABLE IF EXISTS info.object_log_history
    OWNER TO dba_team;

GRANT ALL ON TABLE info.object_log_history TO db_datareader;
GRANT SELECT ON TABLE info.object_log_history TO db_datareader;
GRANT ALL ON TABLE info.object_log_history TO dba_team;
        ';
        RAISE NOTICE 'Table "info.object_log_history" created.';
    ELSE
        RAISE NOTICE 'Table "info.object_log_history" already exists.';
    END IF;
END
$$;
--- END FAILED SCRIPT ---
üìÑ [DBA] /c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/1 initial/model_database_creation.sql
üîó Running: psql -U "jrussell" -h "dba-exp-tst.cluster-clm0vrvchewi.us-east-2.rds.amazonaws.com" -p "5432" -d DBA -f "/c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/1 initial/model_database_creation.sql"
psql: error: connection to server at "dba-exp-tst.cluster-clm0vrvchewi.us-east-2.rds.amazonaws.com" (172.31.24.19), port 5432 failed: FATAL:  database "DBA" does not exist
‚ùå ERROR running /c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/1 initial/model_database_creation.sql against DBA
--- FAILED COMMAND ---
psql -U "jrussell" -h "dba-exp-tst.cluster-clm0vrvchewi.us-east-2.rds.amazonaws.com" -p "5432" -d DBA -f "/c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/1 initial/model_database_creation.sql"
--- BEGIN FAILED SCRIPT: /c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/1 initial/model_database_creation.sql ---

-- ============================================
-- Script: model_database_creation.sql
-- Purpose: Create a 'model' database using template0 and load schema for reuse
-- ============================================
set role dbadmin;

-- Set default db name.
-- We now set the variable to a string that includes the double quotes.
\if :{?modeldbname}
    -- User provided a name, assume it's already quoted or correctly capitalized
    -- and we will pass it through.
    \echo Using user-provided database name: :modeldbname
\else
    -- Default to "DBA" by setting the variable to the quoted string.
    \set modeldbname 'model'
    \echo Using default database name: :modeldbname
\endif
-- Confirm variable
\echo Final database name: :modeldbname


CREATE DATABASE :"modeldbname"
    WITH OWNER = dbadmin
    ENCODING = 'UTF8'
    LC_COLLATE = 'en_US.UTF-8'
    LC_CTYPE = 'en_US.UTF-8'
    TEMPLATE template0;
\connect :modeldbname

-- Load schema
--
-- PostgreSQL database dump
--

-- Dumped from database version 17.5
-- Dumped by pg_dump version 17.5
set role dba_team;
SET statement_timeout = 0;
SET lock_timeout = 0;
SET idle_in_transaction_session_timeout = 0;
SET transaction_timeout = 0;
SET client_encoding = 'UTF8';
SET standard_conforming_strings = on;
SELECT pg_catalog.set_config('search_path', '', false);
SET check_function_bodies = false;
SET xmloption = content;
SET client_min_messages = warning;
SET row_security = off;

--
-- Name: dba; Type: SCHEMA; Schema: -; Owner: dba_team
--

CREATE SCHEMA IF NOT EXISTS dba;


ALTER SCHEMA dba OWNER TO dba_team;

--
-- Name: getprivileges(text); Type: FUNCTION; Schema: dba; Owner: dba_team
--
CREATE OR REPLACE FUNCTION dba.getprivileges(p_role text DEFAULT ''::text) RETURNS TABLE(object_scope text, grantee text, privilege text, inherited_role text, source text)
    LANGUAGE plpgsql
    AS $_$
    DECLARE
        v_ver INT := current_setting('server_version_num')::INT;
    BEGIN
        RETURN QUERY
        -- CTE to get roles and their directly inherited roles
        WITH inherited_roles AS (
            SELECT
                r.rolname AS role_name,
                string_agg(m.rolname, ',' ORDER BY m.rolname) AS inherited_role
            FROM pg_roles r
            LEFT JOIN pg_auth_members am ON r.oid = am.member
            LEFT JOIN pg_roles m ON am.roleid = m.oid
            GROUP BY r.rolname
        ),
        -- CTE for schema CREATE privileges
        schema_create AS (
            SELECT
                n.nspname::TEXT AS object_scope,
                r.rolname::TEXT AS grantee,
                'CREATE'::TEXT AS privilege,
                ir.inherited_role,
                'actual_schema_privilege'::TEXT AS source
            FROM pg_namespace n
            JOIN pg_roles r ON has_schema_privilege(r.rolname, n.oid, 'CREATE')
            LEFT JOIN inherited_roles ir ON r.rolname = ir.role_name
            WHERE n.nspname NOT LIKE 'pg_%' AND n.nspname <> 'information_schema'
        ),
        -- CTE for schema USAGE privileges
        schema_usage AS (
            SELECT
                n.nspname::TEXT AS object_scope,
                r.rolname::TEXT AS grantee,
                'USAGE'::TEXT AS privilege,
                ir.inherited_role,
                'actual_schema_privilege'::TEXT AS source
            FROM pg_namespace n
            JOIN pg_roles r ON has_schema_privilege(r.rolname, n.oid, 'USAGE')
            LEFT JOIN inherited_roles ir ON r.rolname = ir.role_name
            WHERE n.nspname NOT LIKE 'pg_%' AND n.nspname <> 'information_schema'
        ),
        -- CTE for database-level privileges (CREATE, TEMP, CONNECT)
        db_privs AS (
            SELECT
                current_database()::TEXT AS object_scope,
                r.rolname::TEXT AS grantee,
                unnest(string_to_array(
                    TRIM(BOTH ',' FROM
                        CASE WHEN has_database_privilege(r.rolname, current_database(), 'CREATE') THEN 'CREATE,' ELSE '' END ||
                        CASE WHEN has_database_privilege(r.rolname, current_database(), 'TEMP') THEN 'TEMP,' ELSE '' END ||
                        CASE WHEN has_database_privilege(r.rolname, current_database(), 'CONNECT') THEN 'CONNECT' ELSE '' END
                    ), ','))::TEXT AS privilege,
                ir.inherited_role,
                'actual_database_privilege'::TEXT AS source
            FROM pg_roles r
            LEFT JOIN inherited_roles ir ON r.rolname = ir.role_name
        ),
        -- CTE to extract raw ACL entries from pg_default_acl for PG 14+
        raw_acls AS (
            SELECT
                pda.defaclnamespace::regnamespace::TEXT AS object_scope,
                (regexp_matches(acl_entry::TEXT, '^(.+?)=([a-zA-Z]*)/?(.+)?$'))[1]::TEXT AS grantee,
                (regexp_matches(acl_entry::TEXT, '^(.+?)=([a-zA-Z]*)/?(.+)?$'))[2]::TEXT AS privs_raw
            FROM pg_default_acl pda, unnest(pda.defaclacl) AS acl_entry
            WHERE current_setting('server_version_num')::INT >= 140000
        ),
        -- CTE to expand raw ACL characters into full privilege names
        expanded_acls AS (
            SELECT
                ra.object_scope,
                ra.grantee,
                CASE
                    WHEN ra.privs_raw IS NULL THEN NULL
                    ELSE array_to_string(ARRAY(
                        SELECT priv_subquery.privilege FROM (
                            SELECT CASE WHEN ra.privs_raw LIKE '%a%' THEN 'INSERT' END AS privilege
                            UNION ALL SELECT CASE WHEN ra.privs_raw LIKE '%r%' THEN 'SELECT' END
                            UNION ALL SELECT CASE WHEN ra.privs_raw LIKE '%w%' THEN 'UPDATE' END
                            UNION ALL SELECT CASE WHEN ra.privs_raw LIKE '%d%' THEN 'DELETE' END
                            UNION ALL SELECT CASE WHEN ra.privs_raw LIKE '%D%' THEN 'TRUNCATE' END
                            UNION ALL SELECT CASE WHEN ra.privs_raw LIKE '%x%' THEN 'REFERENCES' END
                            UNION ALL SELECT CASE WHEN ra.privs_raw LIKE '%t%' THEN 'TRIGGER' END
                            UNION ALL SELECT CASE WHEN ra.privs_raw LIKE '%X%' THEN 'EXECUTE' END
                        ) AS priv_subquery WHERE priv_subquery.privilege IS NOT NULL ORDER BY priv_subquery.privilege
                    ), ',')
                END AS privilege,
                ir.inherited_role,
                'default_acl'::TEXT AS source
            FROM raw_acls ra
            LEFT JOIN inherited_roles ir ON ra.grantee = ir.role_name
        )

        -- Combine all privilege types and filter by p_role if provided
        SELECT sc.object_scope, sc.grantee, sc.privilege, sc.inherited_role, sc.source FROM schema_create sc WHERE p_role = '' OR sc.grantee = p_role
        UNION ALL
        SELECT su.object_scope, su.grantee, su.privilege, su.inherited_role, su.source FROM schema_usage su WHERE p_role = '' OR su.grantee = p_role
        UNION ALL
        SELECT db.object_scope, db.grantee, db.privilege, db.inherited_role, db.source FROM db_privs db WHERE p_role = '' OR db.grantee = p_role
        UNION ALL
        SELECT ea.object_scope, ea.grantee, ea.privilege, ea.inherited_role, ea.source FROM expanded_acls ea WHERE p_role = '' OR ea.grantee = p_role
        ORDER BY grantee, object_scope, privilege;
    END;
    $_$;


ALTER FUNCTION dba.getprivileges(p_role text) OWNER TO dba_team;



-- Name: SCHEMA dba; Type: ACL; Schema: -; Owner: dba_team


GRANT USAGE ON SCHEMA dba TO db_datareader;
GRANT USAGE ON SCHEMA dba TO db_datawriter;
GRANT USAGE ON SCHEMA dba TO db_ddladmin_c;


--
-- Name: SCHEMA public; Type: ACL; Schema: -; Owner: pg_database_owner
--

GRANT USAGE ON SCHEMA public TO db_ddladmin_c;
GRANT USAGE ON SCHEMA public TO db_datareader;
GRANT USAGE ON SCHEMA public TO db_datawriter;
GRANT ALL ON SCHEMA public TO db_ddladmin;


--
-- Name: FUNCTION getprivileges(p_role text); Type: ACL; Schema: dba; Owner: dba_team
--

GRANT ALL ON FUNCTION dba.getprivileges(p_role text) TO db_datareader;
GRANT ALL ON FUNCTION dba.getprivileges(p_role text) TO db_datawriter;
GRANT ALL ON FUNCTION dba.getprivileges(p_role text) TO db_ddladmin;
GRANT ALL ON FUNCTION dba.getprivileges(p_role text) TO db_ddladmin_c;


--
-- Name: DEFAULT PRIVILEGES FOR TABLES; Type: DEFAULT ACL; Schema: dba; Owner: dba_team
--

ALTER DEFAULT PRIVILEGES FOR ROLE dba_team IN SCHEMA dba GRANT SELECT,INSERT,DELETE,UPDATE ON TABLES TO db_ddladmin;
ALTER DEFAULT PRIVILEGES FOR ROLE dba_team IN SCHEMA dba GRANT SELECT,INSERT,DELETE,UPDATE ON TABLES TO db_datawriter;
ALTER DEFAULT PRIVILEGES FOR ROLE dba_team IN SCHEMA dba GRANT SELECT ON TABLES TO db_datareader;


--
-- Name: DEFAULT PRIVILEGES FOR TABLES; Type: DEFAULT ACL; Schema: public; Owner: dba_team
--

ALTER DEFAULT PRIVILEGES FOR ROLE dba_team IN SCHEMA public GRANT ALL ON TABLES TO db_ddladmin;
ALTER DEFAULT PRIVILEGES FOR ROLE dba_team IN SCHEMA public GRANT ALL ON TABLES TO db_ddladmin_c;
ALTER DEFAULT PRIVILEGES FOR ROLE dba_team IN SCHEMA public GRANT SELECT,INSERT,DELETE,UPDATE ON TABLES TO db_datawriter;
ALTER DEFAULT PRIVILEGES FOR ROLE dba_team IN SCHEMA public GRANT SELECT ON TABLES TO db_datareader;


--
-- PostgreSQL database dump complete
--UPDATE pg_database SET datistemplate = true WHERE datname = :'modeldbname';

-- Optional: restrict access
 REVOKE CONNECT ON DATABASE :modeldbname FROM PUBLIC;
-- GRANT CONNECT ON DATABASE :modeldbname TO :dbaname;

-- ‚úÖ model template created successfully--- END FAILED SCRIPT ---
üìÑ [DBA] /c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/1 initial/role_creations.sql
üîó Running: psql -U "jrussell" -h "dba-exp-tst.cluster-clm0vrvchewi.us-east-2.rds.amazonaws.com" -p "5432" -d DBA -f "/c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/1 initial/role_creations.sql"
psql: error: connection to server at "dba-exp-tst.cluster-clm0vrvchewi.us-east-2.rds.amazonaws.com" (172.31.24.19), port 5432 failed: FATAL:  database "DBA" does not exist
‚ùå ERROR running /c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/1 initial/role_creations.sql against DBA
--- FAILED COMMAND ---
psql -U "jrussell" -h "dba-exp-tst.cluster-clm0vrvchewi.us-east-2.rds.amazonaws.com" -p "5432" -d DBA -f "/c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/1 initial/role_creations.sql"
--- BEGIN FAILED SCRIPT: /c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/1 initial/role_creations.sql ---
set role dbadmin;

-- Create role db_ddladmin if it doesn't exist
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_roles WHERE rolname = 'db_ddladmin') THEN
        CREATE ROLE db_ddladmin 
        WITH NOSUPERUSER NOCREATEDB NOCREATEROLE NOINHERIT NOLOGIN NOREPLICATION NOBYPASSRLS CONNECTION LIMIT -1;
        RAISE NOTICE 'Role "db_ddladmin" created.';
    ELSE
        RAISE NOTICE 'Role "db_ddladmin" already exists.';
    END IF;
END
$$;



-- Create role db_ddladmin if it doesn't exist
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_roles WHERE rolname = 'db_ddladmin_c') THEN
        CREATE ROLE db_ddladmin_c 
        WITH NOSUPERUSER NOCREATEDB NOCREATEROLE NOINHERIT NOLOGIN NOREPLICATION NOBYPASSRLS CONNECTION LIMIT -1;
        RAISE NOTICE 'Role "db_ddladmin_c" created.';
    ELSE
        RAISE NOTICE 'Role "db_ddladmin_c" already exists.';
    END IF;
END
$$;

-- Create role db_datawriter if it doesn't exist
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_roles WHERE rolname = 'db_datawriter') THEN
        CREATE ROLE db_datawriter 
        WITH NOSUPERUSER NOCREATEDB NOCREATEROLE NOINHERIT NOLOGIN NOREPLICATION NOBYPASSRLS CONNECTION LIMIT -1;
        RAISE NOTICE 'Role "db_datawriter" created.';
    ELSE
        RAISE NOTICE 'Role "db_datawriter" already exists.';
    END IF;
END
$$;

-- Create role db_datareader if it doesn't exist
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_roles WHERE rolname = 'db_datareader') THEN
        CREATE ROLE db_datareader 
        WITH NOSUPERUSER NOCREATEDB NOCREATEROLE NOINHERIT NOLOGIN NOREPLICATION NOBYPASSRLS CONNECTION LIMIT -1;
        RAISE NOTICE 'Role "db_datareader" created.';
    ELSE
        RAISE NOTICE 'Role "db_datareader" already exists.';
    END IF;
END
$$;

-- Create role dba_team if it doesn't exist
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_roles WHERE rolname = 'dba_team') THEN
        CREATE ROLE dba_team 
        WITH NOSUPERUSER NOCREATEDB NOCREATEROLE INHERIT NOLOGIN NOREPLICATION NOBYPASSRLS CONNECTION LIMIT -1;
          GRANT dbadmin TO dba_team;
		RAISE NOTICE 'Role "dba_team" created.';
    ELSE
        RAISE NOTICE 'Role "dba_team" already exists.';
    END IF;
END
$$;


-- Grant db_datawriter to dba_team if both roles exist and grant not already applied
DO $$
BEGIN
    IF EXISTS (SELECT 1 FROM pg_roles WHERE rolname = 'db_datawriter')
       AND EXISTS (SELECT 1 FROM pg_roles WHERE rolname = 'dba_team')
       AND NOT EXISTS (
           SELECT 1 
           FROM pg_auth_members 
           WHERE roleid = (SELECT oid FROM pg_roles WHERE rolname = 'db_datawriter')
             AND member = (SELECT oid FROM pg_roles WHERE rolname = 'dba_team')
       ) THEN
        GRANT db_datawriter TO dba_team;
        RAISE NOTICE 'Granted db_datawriter to dba_team.';
    ELSE
        RAISE NOTICE 'Grant db_datawriter to dba_team already exists or roles missing.';
    END IF;
END
$$;

-- Grant db_ddladmin to dba_team
DO $$
BEGIN
    IF EXISTS (SELECT 1 FROM pg_roles WHERE rolname = 'db_ddladmin')
       AND EXISTS (SELECT 1 FROM pg_roles WHERE rolname = 'dba_team')
       AND NOT EXISTS (
           SELECT 1 
           FROM pg_auth_members 
           WHERE roleid = (SELECT oid FROM pg_roles WHERE rolname = 'db_ddladmin')
             AND member = (SELECT oid FROM pg_roles WHERE rolname = 'dba_team')
       ) THEN
        GRANT db_ddladmin TO dba_team;
        RAISE NOTICE 'Granted db_ddladmin to dba_team.';
    ELSE
        RAISE NOTICE 'Grant db_ddladmin to dba_team already exists or roles missing.';
    END IF;
END
$$;

-- Grant db_datareader to dba_team
DO $$
BEGIN
    IF EXISTS (SELECT 1 FROM pg_roles WHERE rolname = 'db_datareader')
       AND EXISTS (SELECT 1 FROM pg_roles WHERE rolname = 'dba_team')
       AND NOT EXISTS (
           SELECT 1 
           FROM pg_auth_members 
           WHERE roleid = (SELECT oid FROM pg_roles WHERE rolname = 'db_datareader')
             AND member = (SELECT oid FROM pg_roles WHERE rolname = 'dba_team')
       ) THEN
        GRANT db_datareader TO dba_team;
        RAISE NOTICE 'Granted db_datareader to dba_team.';
    ELSE
        RAISE NOTICE 'Grant db_datareader to dba_team already exists or roles missing.';
    END IF;
END
$$;


-- Grant db_ddladmin to dba_team
DO $$
BEGIN
    IF EXISTS (SELECT 1 FROM pg_roles WHERE rolname = 'db_ddladmin_c')
       AND EXISTS (SELECT 1 FROM pg_roles WHERE rolname = 'dba_team')
       AND NOT EXISTS (
           SELECT 1 
           FROM pg_auth_members 
           WHERE roleid = (SELECT oid FROM pg_roles WHERE rolname = 'db_ddladmin_c')
             AND member = (SELECT oid FROM pg_roles WHERE rolname = 'dba_team')
       ) THEN
        GRANT db_ddladmin_c TO dba_team;
        RAISE NOTICE 'Granted db_ddladmin_c to dba_team.';
    ELSE
        RAISE NOTICE 'Grant db_ddladmin_c to dba_team already exists or roles missing.';
    END IF;
END
$$;--- END FAILED SCRIPT ---
üìÑ [DBA] /c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/2 deploy/deploy.DropSchemaWithCleanup.sql
üîó Running: psql -U "jrussell" -h "dba-exp-tst.cluster-clm0vrvchewi.us-east-2.rds.amazonaws.com" -p "5432" -d DBA -f "/c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/2 deploy/deploy.DropSchemaWithCleanup.sql"
psql: error: connection to server at "dba-exp-tst.cluster-clm0vrvchewi.us-east-2.rds.amazonaws.com" (172.31.24.19), port 5432 failed: FATAL:  database "DBA" does not exist
‚ùå ERROR running /c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/2 deploy/deploy.DropSchemaWithCleanup.sql against DBA
--- FAILED COMMAND ---
psql -U "jrussell" -h "dba-exp-tst.cluster-clm0vrvchewi.us-east-2.rds.amazonaws.com" -p "5432" -d DBA -f "/c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/2 deploy/deploy.DropSchemaWithCleanup.sql"
--- BEGIN FAILED SCRIPT: /c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/2 deploy/deploy.DropSchemaWithCleanup.sql ---
set role dba_team; 

CREATE OR REPLACE FUNCTION deploy.DropSchemaWithCleanup(
    p_schema_name TEXT,
    p_execute_flag BOOLEAN DEFAULT FALSE,
    p_cascade BOOLEAN DEFAULT FALSE
)
RETURNS TEXT
LANGUAGE plpgsql
AS $$
DECLARE
    v_exists BOOLEAN;
    v_sql TEXT;
    v_log_status TEXT;
BEGIN
    SELECT EXISTS (
        SELECT 1 FROM information_schema.schemata WHERE schema_name = p_schema_name
    ) INTO v_exists;

    IF NOT v_exists THEN
        v_log_status := 'NOT_FOUND';
        RAISE NOTICE 'Schema "%" does not exist.', p_schema_name;

        INSERT INTO dba.object_log_history (
            action_type, target_entity, associated_entity, status, sql_command, message
        ) VALUES (
            'DROP_SCHEMA',
            p_schema_name,
            NULL,
            v_log_status,
            NULL,
           'No schema dropped ‚Äî not found.'       -- if your editor truly supports UTF-8
        );

        RETURN format('Schema "%s" does not exist.', p_schema_name);
    END IF;

    v_sql := format('DROP SCHEMA %I %s',
        p_schema_name,
        CASE WHEN p_cascade THEN 'CASCADE' ELSE 'RESTRICT' END
    );

    RAISE NOTICE '[DRY-RUN] Would drop schema: %', p_schema_name;

    IF p_execute_flag THEN
        EXECUTE v_sql;
        v_log_status := 'EXECUTED';
        RAISE NOTICE 'Schema "%" dropped.', p_schema_name;
    ELSE
        v_log_status := 'DRY_RUN';
    END IF;

    INSERT INTO dba.object_log_history (
        action_type, target_entity, associated_entity, status, sql_command, message
    ) VALUES (
        'DROP_SCHEMA',
        p_schema_name,
        NULL,
        v_log_status,
        v_sql,
        'Schema drop processed.'
    );

    RETURN format('Schema "%s" drop %s.', p_schema_name, v_log_status);
END;
$$;

ALTER FUNCTION deploy.DropSchemaWithCleanup(TEXT, BOOLEAN, BOOLEAN)
OWNER TO dba_team;
--- END FAILED SCRIPT ---
üìÑ [DBA] /c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/2 deploy/deploy.SetAccountRevoke.sql
üîó Running: psql -U "jrussell" -h "dba-exp-tst.cluster-clm0vrvchewi.us-east-2.rds.amazonaws.com" -p "5432" -d DBA -f "/c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/2 deploy/deploy.SetAccountRevoke.sql"
psql: error: connection to server at "dba-exp-tst.cluster-clm0vrvchewi.us-east-2.rds.amazonaws.com" (172.31.24.19), port 5432 failed: FATAL:  database "DBA" does not exist
‚ùå ERROR running /c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/2 deploy/deploy.SetAccountRevoke.sql against DBA
--- FAILED COMMAND ---
psql -U "jrussell" -h "dba-exp-tst.cluster-clm0vrvchewi.us-east-2.rds.amazonaws.com" -p "5432" -d DBA -f "/c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/2 deploy/deploy.SetAccountRevoke.sql"
--- BEGIN FAILED SCRIPT: /c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/2 deploy/deploy.SetAccountRevoke.sql ---
-- FUNCTION: deploy.setaccountrevoke(text[], text[], text[], text[], text[], boolean, boolean)

-- DROP FUNCTION IF EXISTS deploy.setaccountrevoke(text[], text[], text[], text[], text[], boolean, boolean);
set role dba_team; 


CREATE OR REPLACE FUNCTION deploy.SetAccountRevoke(
    p_usernames TEXT[] DEFAULT NULL,
    p_role_names TEXT[] DEFAULT NULL,
    p_schemas TEXT[] DEFAULT NULL,
    p_inherit_roles TEXT[] DEFAULT NULL,
    p_object_roles TEXT[] DEFAULT NULL,
    p_execute_flag BOOLEAN DEFAULT FALSE,
    p_verbose_flag BOOLEAN DEFAULT FALSE
)
    RETURNS text
    LANGUAGE plpgsql
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $$
DECLARE
    v_result TEXT := '';
BEGIN
    -- Step 1: Revoke user inheritance (GRANT role TO user)
    IF p_usernames IS NOT NULL AND p_inherit_roles IS NOT NULL THEN
        v_result := v_result || deploy.SetRevokeUser(
            p_usernames := p_usernames,
            p_inherit_roles := p_inherit_roles,
            p_execute_flag := p_execute_flag
        ) || E'\n';
    END IF;

    -- Step 2: Drop users
    IF p_usernames IS NOT NULL THEN
        v_result := v_result || deploy.SetRevokeUser(
            p_usernames := p_usernames,
            p_execute_flag := p_execute_flag
        ) || E'\n';
    END IF;

    -- Step 3: Revoke object-level permissions for roles
    IF p_object_roles IS NOT NULL AND p_schemas IS NOT NULL THEN
        v_result := v_result || deploy.SetRevokeRolePermissions(
            p_roles := p_object_roles,
            p_schemas := p_schemas,
            p_execute_flag := p_execute_flag
        ) || E'\n';
    END IF;

    -- Step 4: Drop roles
    IF p_role_names IS NOT NULL THEN
        v_result := v_result || deploy.SetRoleRevoke(
            p_roles := p_role_names,
            p_execute_flag := p_execute_flag
        ) || E'\n';
    END IF;

    RETURN v_result;
END;
$$;

ALTER FUNCTION deploy.SetAccountRevoke(
    TEXT[], TEXT[], TEXT[], TEXT[], TEXT[], BOOLEAN, BOOLEAN
) OWNER TO dba_team;
--- END FAILED SCRIPT ---
üìÑ [DBA] /c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/2 deploy/deploy.SetAccountSetup.sql
üîó Running: psql -U "jrussell" -h "dba-exp-tst.cluster-clm0vrvchewi.us-east-2.rds.amazonaws.com" -p "5432" -d DBA -f "/c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/2 deploy/deploy.SetAccountSetup.sql"
psql: error: connection to server at "dba-exp-tst.cluster-clm0vrvchewi.us-east-2.rds.amazonaws.com" (172.31.24.19), port 5432 failed: FATAL:  database "DBA" does not exist
‚ùå ERROR running /c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/2 deploy/deploy.SetAccountSetup.sql against DBA
--- FAILED COMMAND ---
psql -U "jrussell" -h "dba-exp-tst.cluster-clm0vrvchewi.us-east-2.rds.amazonaws.com" -p "5432" -d DBA -f "/c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/2 deploy/deploy.SetAccountSetup.sql"
--- BEGIN FAILED SCRIPT: /c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/2 deploy/deploy.SetAccountSetup.sql ---
-- Create or replace the parent function to handle full account setup

set role dba_team; 


CREATE OR REPLACE FUNCTION deploy.SetAccountSetup(
    p_role_names TEXT[] DEFAULT NULL,
    p_usernames TEXT[] DEFAULT NULL,
    p_user_password TEXT DEFAULT NULL,
    p_user_inherit_roles TEXT[] DEFAULT NULL,
    p_apply_schema_privs_to_roles TEXT[] DEFAULT NULL,
    p_table_privileges TEXT[] DEFAULT NULL,
    p_function_privileges TEXT[] DEFAULT NULL,
    p_apply_to_existing_tables BOOLEAN DEFAULT FALSE,
    p_set_default_for_future_tables BOOLEAN DEFAULT FALSE,
    p_set_default_for_future_functions BOOLEAN DEFAULT FALSE,
    p_revoke_all_first BOOLEAN DEFAULT FALSE,
    p_execute_flag BOOLEAN DEFAULT FALSE
)
RETURNS TEXT
LANGUAGE plpgsql
AS $$
/*
-- ===============================
-- EXAMPLE 1: Only Create Roles
-- ===============================
SELECT deploy.SetAccountSetup(
    p_role_names := ARRAY['app_reader', 'app_writer']
);

-- ===============================
-- EXAMPLE 2: Only Create Users
-- ===============================
SELECT deploy.SetAccountSetup(
    p_usernames := ARRAY['johndoe', 'janedoe'],
    p_user_password := 'SuperSecure123!',
    p_user_inherit_roles := ARRAY['app_reader']
);

-- ===============================
-- EXAMPLE 3: Only Apply Permissions
-- ===============================
SELECT deploy.SetAccountSetup(
    p_apply_schema_privs_to_roles := ARRAY['app_reader'],
    p_table_privileges := ARRAY['SELECT'],
    p_function_privileges := ARRAY['EXECUTE'],
    p_apply_to_existing_tables := TRUE,
    p_set_default_for_future_tables := TRUE,
    p_set_default_for_future_functions := TRUE
);

-- ===============================
-- EXAMPLE 4: Create Roles + Apply Permissions (no user)
-- ===============================
SELECT deploy.SetAccountSetup(
    p_role_names := ARRAY['app_reader'],
    p_user_inherit_roles := ARRAY['base_role'],
    p_apply_schema_privs_to_roles := ARRAY['app_reader'],
    p_table_privileges := ARRAY['SELECT'],
    p_execute_flag := TRUE
);

-- ===============================
-- EXAMPLE 5: Create Roles + Users (no permissions)
-- ===============================
SELECT deploy.SetAccountSetup(
    p_role_names := ARRAY['app_writer'],
    p_usernames := ARRAY['service_account'],
    p_user_password := 'pw123!',
    p_user_inherit_roles := ARRAY['app_writer'],
    p_execute_flag := TRUE
);

-- ===============================
-- EXAMPLE 6: Full Setup (Roles + Permissions + Users)
-- ===============================
SELECT deploy.SetAccountSetup(
    p_role_names := ARRAY['db_datareader'],
    p_usernames := ARRAY['alice'],
    p_user_password := 'alice123!',
    p_user_inherit_roles := ARRAY['db_datareader'],
    p_apply_schema_privs_to_roles := ARRAY['db_datareader'],
    p_table_privileges := ARRAY['SELECT'],
    p_function_privileges := ARRAY['EXECUTE'],
    p_apply_to_existing_tables := TRUE,
    p_set_default_for_future_tables := TRUE,
    p_execute_flag := TRUE
);

-- ===============================
-- EXAMPLE 7: Dry Run Preview (Any of the above)
-- ===============================
SELECT deploy.SetAccountSetup(
    p_usernames := ARRAY['dryrun_user'],
    p_user_password := 'notused',
    p_user_inherit_roles := ARRAY['no_inherit'],
    p_execute_flag := FALSE -- DRY RUN!
);
*/
DECLARE
    v_result TEXT := '';
BEGIN
    -- Step 1: Role Creation
    IF p_role_names IS NOT NULL AND array_length(p_role_names, 1) > 0 THEN
        v_result := v_result || deploy.SetRoleCreation(
            p_role_names := p_role_names,
            p_user_inherit_roles := p_user_inherit_roles,
            p_execute_flag := p_execute_flag
        ) || E'\n';
    END IF;

    -- Step 2: Grant Permissions
    IF p_apply_schema_privs_to_roles IS NOT NULL AND (p_table_privileges IS NOT NULL OR p_function_privileges IS NOT NULL) THEN
        v_result := v_result || deploy.SetRolePermissions(
            p_apply_schema_privs_to_roles := p_apply_schema_privs_to_roles,
            p_table_privileges := p_table_privileges,
            p_function_privileges := p_function_privileges,
            p_apply_to_existing_tables := p_apply_to_existing_tables,
            p_set_default_for_future_tables := p_set_default_for_future_tables,
            p_set_default_for_future_functions := p_set_default_for_future_functions,
            p_revoke_all_first := p_revoke_all_first,
            p_execute_flag := p_execute_flag
        ) || E'\n';
    END IF;

    -- Step 3: Create Users
    IF p_usernames IS NOT NULL AND array_length(p_usernames, 1) > 0 THEN
        v_result := v_result || deploy.SetCreateUser(
            p_usernames := p_usernames,
            p_user_password := p_user_password,
            p_user_inherit_roles := p_user_inherit_roles,
            p_execute_flag := p_execute_flag
        ) || E'\n';
    END IF;

    RETURN v_result;
END;
$$;
--- END FAILED SCRIPT ---
üìÑ [DBA] /c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/2 deploy/deploy.SetCreateUser.sql
üîó Running: psql -U "jrussell" -h "dba-exp-tst.cluster-clm0vrvchewi.us-east-2.rds.amazonaws.com" -p "5432" -d DBA -f "/c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/2 deploy/deploy.SetCreateUser.sql"
psql: error: connection to server at "dba-exp-tst.cluster-clm0vrvchewi.us-east-2.rds.amazonaws.com" (172.31.24.19), port 5432 failed: FATAL:  database "DBA" does not exist
‚ùå ERROR running /c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/2 deploy/deploy.SetCreateUser.sql against DBA
--- FAILED COMMAND ---
psql -U "jrussell" -h "dba-exp-tst.cluster-clm0vrvchewi.us-east-2.rds.amazonaws.com" -p "5432" -d DBA -f "/c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/2 deploy/deploy.SetCreateUser.sql"
--- BEGIN FAILED SCRIPT: /c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/2 deploy/deploy.SetCreateUser.sql ---
-- ================================================================
-- FUNCTION: deploy.SetCreateUser()
-- DESCRIPTION: Creates users, assigns roles, logs actions securely
-- OWNER: dba_team
-- ==============================================================

-- DROP FUNCTION IF EXISTS deploy.setcreateuser(text[], text, text[], boolean);
set role dba_team; 


CREATE OR REPLACE FUNCTION deploy.setcreateuser(
    p_usernames TEXT[],
    p_user_password TEXT DEFAULT NULL,
    p_user_inherit_roles TEXT[] DEFAULT NULL,
    p_execute_flag BOOLEAN DEFAULT FALSE
)
RETURNS TEXT
LANGUAGE plpgsql
COST 100
VOLATILE PARALLEL UNSAFE
AS $$
DECLARE
    v_entity_exists BOOLEAN;
    v_is_member BOOLEAN;
    v_sql_command TEXT;
    v_sql_command_real TEXT;
    v_log_status TEXT;
    v_return_message TEXT := '';
    v_current_user_name TEXT;
    v_current_inherit_role TEXT;
    v_generated_password TEXT;
    password_mask_pattern TEXT := E'WITH (?:LOGIN\s+)?PASSWORD\s+''[^'']*''';
    masked_password_string TEXT := 'WITH LOGIN PASSWORD ''xxxxxxxxxxxxxx''';
BEGIN
    IF p_usernames IS NOT NULL AND array_length(p_usernames, 1) > 0 THEN
        FOREACH v_current_user_name IN ARRAY p_usernames LOOP
            SELECT EXISTS (SELECT 1 FROM pg_roles WHERE rolname = v_current_user_name)
            INTO v_entity_exists;

            v_generated_password := p_user_password;
            IF v_generated_password IS NULL THEN
                v_generated_password := v_current_user_name || 'Pass123!';
                RAISE NOTICE 'Default password assigned for user "%".', v_current_user_name;
            END IF;

            IF NOT v_entity_exists THEN
                v_sql_command := format('CREATE ROLE %I WITH LOGIN PASSWORD ''xxxxxxxxxxxxxx''', v_current_user_name);
                v_sql_command_real := format('CREATE ROLE %I WITH LOGIN PASSWORD %L', v_current_user_name, v_generated_password);
                RAISE NOTICE '[DRY-RUN] Would create user: "%"', v_current_user_name;

                IF p_execute_flag THEN
                    EXECUTE v_sql_command_real;
                    v_log_status := 'EXECUTED';
                    RAISE NOTICE 'User "%s" created.', v_current_user_name;
                ELSE
                    v_log_status := 'DRY_RUN';
                END IF;

                INSERT INTO info.account_log_history (
                    action_type,
                    target_entity,
                    associated_entity,
                    status,
                    sql_command,
                    message
                ) VALUES (
                    'CREATE_USER',
                    v_current_user_name,
                    NULL,
                    v_log_status,
                    v_sql_command,
                    'User creation attempted.' || CASE WHEN v_log_status = 'EXECUTED' THEN ' Password set (not logged).' ELSE '' END
                );

                v_return_message := v_return_message || format('User "%s" created. ', v_current_user_name);
            ELSE
                v_log_status := 'ALREADY_EXISTS';
                INSERT INTO info.account_log_history (
                    action_type,
                    target_entity,
                    associated_entity,
                    status,
                    sql_command,
                    message
                ) VALUES (
                    'CREATE_USER',
                    v_current_user_name,
                    NULL,
                    v_log_status,
                    NULL,
                    'User already existed, no action taken.'
                );
            END IF;

            IF p_user_inherit_roles IS NOT NULL AND array_length(p_user_inherit_roles, 1) > 0 THEN
                FOREACH v_current_inherit_role IN ARRAY p_user_inherit_roles LOOP
                    SELECT EXISTS (SELECT 1 FROM pg_roles WHERE rolname = v_current_inherit_role)
                    INTO v_entity_exists;

                    IF NOT v_entity_exists THEN
                        RAISE WARNING 'Inheritance role "%" for user "%" does not exist. Skipping grant.', v_current_inherit_role, v_current_user_name;
                        INSERT INTO info.account_log_history (
                            action_type,
                            target_entity,
                            associated_entity,
                            status,
                            sql_command,
                            message
                        ) VALUES (
                            'GRANT_MEMBERSHIP',
                            v_current_user_name,
                            v_current_inherit_role,
                            'SKIPPED',
                            NULL,
                            format('Inheritance role "%s" does not exist for user "%s". Grant skipped.', v_current_inherit_role, v_current_user_name)
                        );
                        CONTINUE;
                    END IF;

                    SELECT EXISTS (
                        SELECT 1
                        FROM pg_auth_members m
                        JOIN pg_roles r1 ON m.roleid = r1.oid
                        JOIN pg_roles r2 ON m.member = r2.oid
                        WHERE r1.rolname = v_current_inherit_role
                          AND r2.rolname = v_current_user_name
                    ) INTO v_is_member;

                    IF NOT v_is_member THEN
                        v_sql_command := format('GRANT %I TO %I', v_current_inherit_role, v_current_user_name);
                        IF p_execute_flag THEN
                            EXECUTE v_sql_command;
                            v_log_status := 'EXECUTED';
                        ELSE
                            v_log_status := 'DRY_RUN';
                        END IF;

                        INSERT INTO info.account_log_history (
                            action_type,
                            target_entity,
                            associated_entity,
                            status,
                            sql_command,
                            message
                        ) VALUES (
                            'GRANT_MEMBERSHIP',
                            v_current_user_name,
                            v_current_inherit_role,
                            v_log_status,
                            v_sql_command,
                            'Granted inheritance role to user.'
                        );
                    END IF;
                END LOOP;
            END IF;
        END LOOP;
    END IF;

    RETURN v_return_message;
END;
$$;

ALTER FUNCTION deploy.setcreateuser(text[], text, text[], boolean)
    OWNER TO dba_team;
--- END FAILED SCRIPT ---
üìÑ [DBA] /c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/2 deploy/deploy.SetRevokeRolePermissions.sql
üîó Running: psql -U "jrussell" -h "dba-exp-tst.cluster-clm0vrvchewi.us-east-2.rds.amazonaws.com" -p "5432" -d DBA -f "/c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/2 deploy/deploy.SetRevokeRolePermissions.sql"
psql: error: connection to server at "dba-exp-tst.cluster-clm0vrvchewi.us-east-2.rds.amazonaws.com" (172.31.24.19), port 5432 failed: FATAL:  database "DBA" does not exist
‚ùå ERROR running /c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/2 deploy/deploy.SetRevokeRolePermissions.sql against DBA
--- FAILED COMMAND ---
psql -U "jrussell" -h "dba-exp-tst.cluster-clm0vrvchewi.us-east-2.rds.amazonaws.com" -p "5432" -d DBA -f "/c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/2 deploy/deploy.SetRevokeRolePermissions.sql"
--- BEGIN FAILED SCRIPT: /c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/2 deploy/deploy.SetRevokeRolePermissions.sql ---
-- ===============================================
-- FUNCTION: deploy.SetRevokeRolePermissions()
-- DESCRIPTION: Revokes table/function privileges, removes users from roles,
--              optionally drops roles, and logs actions.
-- OWNER: dba_team
-- ===============================================

set role dba_team; 


CREATE OR REPLACE FUNCTION deploy.SetRevokeRolePermissions(
    p_role_names TEXT[],
    p_users_to_remove TEXT[] DEFAULT NULL,
    p_schema_targets TEXT[] DEFAULT NULL,
    p_revoke_table_privileges TEXT[] DEFAULT NULL,
    p_revoke_function_privileges TEXT[] DEFAULT NULL,
    p_drop_roles BOOLEAN DEFAULT FALSE,
    p_execute_flag BOOLEAN DEFAULT FALSE
)
RETURNS TEXT
LANGUAGE plpgsql
COST 100
VOLATILE PARALLEL UNSAFE
AS $$
DECLARE
    v_role TEXT;
    v_user TEXT;
    v_schema TEXT;
    v_priv TEXT;
    v_sql TEXT;
    v_log TEXT := '';
    v_log_status TEXT;
BEGIN
    FOREACH v_role IN ARRAY p_role_names LOOP

        -- Remove role from users
        IF p_users_to_remove IS NOT NULL THEN
            FOREACH v_user IN ARRAY p_users_to_remove LOOP
                v_sql := format('REVOKE %I FROM %I;', v_role, v_user);
                IF p_execute_flag THEN EXECUTE v_sql; END IF;
                v_log_status := CASE WHEN p_execute_flag THEN 'EXECUTED' ELSE 'DRY_RUN' END;
                INSERT INTO info.account_log_history (action_type, target_entity, associated_entity, status, sql_command, message)
                VALUES ('REVOKE_ROLE', v_user, v_role, v_log_status, v_sql, 'Revoked role from user');
                v_log := v_log || v_sql || E'\n';
            END LOOP;
        END IF;

        --Revoke schema/table/function privileges
        IF p_schema_targets IS NOT NULL THEN
            FOREACH v_schema IN ARRAY p_schema_targets LOOP

                -- Revoke TABLE privileges
                IF p_revoke_table_privileges IS NOT NULL THEN
                    FOREACH v_priv IN ARRAY p_revoke_table_privileges LOOP
                        v_sql := format('REVOKE %s ON ALL TABLES IN SCHEMA %I FROM %I;', v_priv, v_schema, v_role);
                        IF p_execute_flag THEN EXECUTE v_sql; END IF;
                        v_log_status := CASE WHEN p_execute_flag THEN 'EXECUTED' ELSE 'DRY_RUN' END;
                        INSERT INTO info.account_log_history (action_type, target_entity, associated_entity, status, sql_command, message)
                        VALUES ('REVOKE_TABLES', v_role, v_schema, v_log_status, v_sql, 'Revoked table privilege');
                        v_log := v_log || v_sql || E'\n';
                    END LOOP;
                END IF;

                -- Revoke FUNCTION privileges
                IF p_revoke_function_privileges IS NOT NULL THEN
                    FOREACH v_priv IN ARRAY p_revoke_function_privileges LOOP
                        v_sql := format('REVOKE %s ON ALL FUNCTIONS IN SCHEMA %I FROM %I;', v_priv, v_schema, v_role);
                        IF p_execute_flag THEN EXECUTE v_sql; END IF;
                        v_log_status := CASE WHEN p_execute_flag THEN 'EXECUTED' ELSE 'DRY_RUN' END;
                        INSERT INTO info.account_log_history (action_type, target_entity, associated_entity, status, sql_command, message)
                        VALUES ('REVOKE_FUNCTIONS', v_role, v_schema, v_log_status, v_sql, 'Revoked function privilege');
                        v_log := v_log || v_sql || E'\n';
                    END LOOP;
                END IF;
            END LOOP;
        END IF;

        -- Drop Role if requested
        IF p_drop_roles THEN
            v_sql := format('DROP ROLE IF EXISTS %I;', v_role);
            IF p_execute_flag THEN EXECUTE v_sql; END IF;
            v_log_status := CASE WHEN p_execute_flag THEN 'EXECUTED' ELSE 'DRY_RUN' END;
            INSERT INTO info.account_log_history (action_type, target_entity, associated_entity, status, sql_command, message)
            VALUES ('DROP_ROLE', v_role, NULL, v_log_status, v_sql, 'Dropped role');
            v_log := v_log || v_sql || E'\n';
        END IF;
		
    END LOOP;
    RETURN v_log;
END;
$$;
ALTER FUNCTION deploy.SetRevokeRolePermissions(
    TEXT[], TEXT[], TEXT[], TEXT[], TEXT[],
    BOOLEAN, BOOLEAN
) OWNER TO dba_team;--- END FAILED SCRIPT ---
üìÑ [DBA] /c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/2 deploy/deploy.SetRevokeUser.sql
üîó Running: psql -U "jrussell" -h "dba-exp-tst.cluster-clm0vrvchewi.us-east-2.rds.amazonaws.com" -p "5432" -d DBA -f "/c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/2 deploy/deploy.SetRevokeUser.sql"
psql: error: connection to server at "dba-exp-tst.cluster-clm0vrvchewi.us-east-2.rds.amazonaws.com" (172.31.24.19), port 5432 failed: FATAL:  database "DBA" does not exist
‚ùå ERROR running /c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/2 deploy/deploy.SetRevokeUser.sql against DBA
--- FAILED COMMAND ---
psql -U "jrussell" -h "dba-exp-tst.cluster-clm0vrvchewi.us-east-2.rds.amazonaws.com" -p "5432" -d DBA -f "/c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/2 deploy/deploy.SetRevokeUser.sql"
--- BEGIN FAILED SCRIPT: /c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/2 deploy/deploy.SetRevokeUser.sql ---
-- FUNCTION: deploy.setrevokeuser(text[], text[], boolean, boolean)

-- DROP FUNCTION IF EXISTS deploy.setrevokeuser(text[], text[], boolean, boolean);
set role dba_team; 


CREATE OR REPLACE FUNCTION deploy.SetRevokeUser(
    p_usernames TEXT[],
    p_inherit_roles TEXT[] DEFAULT NULL,
    p_execute_flag BOOLEAN DEFAULT FALSE,
    p_drop_user BOOLEAN DEFAULT FALSE
)
RETURNS TEXT
LANGUAGE plpgsql
/*


SELECT deploy.SetRevokeUser(
    p_usernames     := ARRAY['superman'],
    p_inherit_roles := ARRAY['db_datareader'],
    p_execute_flag  := TRUE,
    p_drop_user     := TRUE
);

/*
============================================================================
üß™ DRY-RUN ONLY ‚Äî TEST REVOKING ROLES (DON'T EXECUTE)
============================================================================
*/
SELECT deploy.SetRevokeUser(
    p_usernames     := ARRAY['user_qa', 'user_test'],
    p_inherit_roles := ARRAY['db_viewer', 'db_readonly'],
    p_execute_flag  := FALSE,
    p_drop_user     := FALSE
);

/*
============================================================================
ü™ì REVOKE ROLES FROM USERS ‚Äî THEN DROP USERS (default behavior)
============================================================================
*/
SELECT deploy.SetRevokeUser(
    p_usernames     := ARRAY['user_temp1', 'user_temp2'],
    p_inherit_roles := ARRAY['db_datareader', 'db_function_exec'],
    p_execute_flag  := TRUE
    -- p_drop_user is TRUE by default
);

/*
============================================================================
üõë REVOKE ROLES ONLY ‚Äî DO NOT DROP USERS
============================================================================
*/
SELECT deploy.SetRevokeUser(
    p_usernames     := ARRAY['jrussell'],
    p_inherit_roles := ARRAY['db_datareader'],
    p_execute_flag  := TRUE,
    p_drop_user     := FALSE
);

/*
============================================================================
üî• DROP USERS WITHOUT REVOKING ANYTHING
============================================================================
*/
SELECT deploy.SetRevokeUser(
    p_usernames     := ARRAY['old_admin1', 'retired_user'],
    p_execute_flag  := TRUE,
    p_drop_user     := TRUE
);

/*
============================================================================
üëÄ DRY-RUN FULL DESTRUCTION ‚Äî SEE EVERYTHING THAT WOULD HAPPEN
============================================================================
*/
SELECT deploy.SetRevokeUser(
    p_usernames     := ARRAY['intern_doomed'],
    p_inherit_roles := ARRAY['db_temp'],
    p_execute_flag  := FALSE,
    p_drop_user     := TRUE
);

/*
============================================================================
üßæ BONUS: Inside a Batch Job or Admin Script
============================================================================
*/
DO $$
BEGIN
    PERFORM deploy.SetRevokeUser(
        p_usernames     := ARRAY['app_bot1', 'app_bot2'],
        p_inherit_roles := ARRAY['db_execute_only'],
        p_execute_flag  := TRUE,
        p_drop_user     := TRUE
    );
END
$$;



*/
AS $$
DECLARE
    v_user TEXT;
    v_role TEXT;
    v_sql TEXT;
    v_log_status TEXT;
    v_result TEXT := '';
BEGIN
    IF p_usernames IS NULL OR array_length(p_usernames, 1) = 0 THEN
        RETURN '[WARN] No usernames provided.';
    END IF;

    -- Revoke inherited roles if provided
    IF p_inherit_roles IS NOT NULL THEN
        FOREACH v_user IN ARRAY p_usernames LOOP
            FOREACH v_role IN ARRAY p_inherit_roles LOOP
                v_sql := format('REVOKE %I FROM %I;', v_role, v_user);

                IF p_execute_flag THEN
                    EXECUTE v_sql;
                    v_log_status := 'EXECUTED';
                ELSE
                    v_log_status := 'DRY_RUN';
                END IF;

                INSERT INTO info.account_log_history (
                    action_type, target_entity, associated_entity, status, sql_command, message
                ) VALUES (
                    'REVOKE_ROLE', v_user, v_role, v_log_status, v_sql,
                    'Revoked role from user.'
                );

                v_result := v_result || format('[%s] %s\n', v_log_status, v_sql);
            END LOOP;
        END LOOP;
    END IF;

    -- Optionally drop users
    IF p_drop_user THEN
        FOREACH v_user IN ARRAY p_usernames LOOP
            v_sql := format('DROP ROLE IF EXISTS %I;', v_user);

            IF p_execute_flag THEN
                EXECUTE v_sql;
                v_log_status := 'EXECUTED';
            ELSE
                v_log_status := 'DRY_RUN';
            END IF;

            INSERT INTO info.account_log_history (
                action_type, target_entity, associated_entity, status, sql_command, message
            ) VALUES (
                'DROP_USER', v_user, NULL, v_log_status, v_sql,
                'Dropped user account.'
            );

            v_result := v_result || format('[%s] %s\n', v_log_status, v_sql);
        END LOOP;
    END IF;

    RETURN v_result;
END;
$$;

ALTER FUNCTION deploy.SetRevokeUser(TEXT[], TEXT[], BOOLEAN, BOOLEAN)
    OWNER TO dba_team;
--- END FAILED SCRIPT ---
üìÑ [DBA] /c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/2 deploy/deploy.SetRolePermissions.sql
üîó Running: psql -U "jrussell" -h "dba-exp-tst.cluster-clm0vrvchewi.us-east-2.rds.amazonaws.com" -p "5432" -d DBA -f "/c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/2 deploy/deploy.SetRolePermissions.sql"
psql: error: connection to server at "dba-exp-tst.cluster-clm0vrvchewi.us-east-2.rds.amazonaws.com" (172.31.24.19), port 5432 failed: FATAL:  database "DBA" does not exist
‚ùå ERROR running /c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/2 deploy/deploy.SetRolePermissions.sql against DBA
--- FAILED COMMAND ---
psql -U "jrussell" -h "dba-exp-tst.cluster-clm0vrvchewi.us-east-2.rds.amazonaws.com" -p "5432" -d DBA -f "/c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/2 deploy/deploy.SetRolePermissions.sql"
--- BEGIN FAILED SCRIPT: /c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/2 deploy/deploy.SetRolePermissions.sql ---
-- ===============================================
-- FUNCTION: deploy.SetRolePermissions()
-- DESCRIPTION: Creates roles, grants table/function privileges,
--              optionally assigns users to roles, and logs actions.
-- OWNER: dba_team
-- ===============================================
set role dba_team; 

CREATE OR REPLACE FUNCTION deploy.setrolepermissions(
    p_role_names TEXT[],
    p_users_to_assign TEXT[] DEFAULT NULL,
    p_apply_schema_privs_to_roles TEXT[] DEFAULT NULL,
    p_table_privileges TEXT[] DEFAULT NULL,
    p_function_privileges TEXT[] DEFAULT NULL,
    p_apply_to_existing_tables BOOLEAN DEFAULT FALSE,
    p_set_default_for_future_tables BOOLEAN DEFAULT FALSE,
    p_set_default_for_future_functions BOOLEAN DEFAULT FALSE,
    p_revoke_all_first BOOLEAN DEFAULT FALSE,
    p_execute_flag BOOLEAN DEFAULT FALSE
)
RETURNS TEXT
LANGUAGE plpgsql
COST 100
VOLATILE PARALLEL UNSAFE
AS $$
DECLARE
    v_role TEXT;
    v_user TEXT;
    v_schema TEXT;
    v_priv TEXT;
    v_sql TEXT;
    v_log TEXT := '';
    v_exists BOOLEAN;
    v_log_status TEXT;
BEGIN
    FOREACH v_role IN ARRAY p_role_names LOOP
        SELECT EXISTS (SELECT 1 FROM pg_roles WHERE rolname = v_role) INTO v_exists;
        IF NOT v_exists THEN
            v_sql := format('CREATE ROLE %I;', v_role);
            IF p_execute_flag THEN EXECUTE v_sql; END IF;
            v_log_status := CASE WHEN p_execute_flag THEN 'EXECUTED' ELSE 'DRY_RUN' END;
            INSERT INTO info.account_log_history (action_type, target_entity, associated_entity, status, sql_command, message)
            VALUES ('CREATE_ROLE', v_role, NULL, v_log_status, v_sql, 'Role creation');
            v_log := v_log || v_sql || E'\n';
        END IF;

        IF p_users_to_assign IS NOT NULL THEN
            FOREACH v_user IN ARRAY p_users_to_assign LOOP
                v_sql := format('GRANT %I TO %I;', v_role, v_user);
                IF p_execute_flag THEN EXECUTE v_sql; END IF;
                v_log_status := CASE WHEN p_execute_flag THEN 'EXECUTED' ELSE 'DRY_RUN' END;
                INSERT INTO info.account_log_history (action_type, target_entity, associated_entity, status, sql_command, message)
                VALUES ('GRANT_ROLE', v_role, v_user, v_log_status, v_sql, 'Granted role to user');
                v_log := v_log || v_sql || E'\n';
            END LOOP;
        END IF;

        IF p_apply_schema_privs_to_roles IS NOT NULL THEN
            FOREACH v_schema IN ARRAY p_apply_schema_privs_to_roles LOOP
                SELECT EXISTS (
                    SELECT 1
                    FROM information_schema.schemata
                    WHERE schema_name = v_schema
                ) INTO v_exists;

                IF NOT v_exists THEN
                    v_log := v_log || format('-- Skipped schema %I (not found)', v_schema) || E'\n';
                    CONTINUE;
                END IF;

                IF p_revoke_all_first THEN
                    v_sql := format('REVOKE ALL PRIVILEGES ON ALL TABLES IN SCHEMA %I FROM %I;', v_schema, v_role);
                    IF p_execute_flag THEN EXECUTE v_sql; END IF;
                    v_log_status := CASE WHEN p_execute_flag THEN 'EXECUTED' ELSE 'DRY_RUN' END;
                    INSERT INTO info.account_log_history (action_type, target_entity, associated_entity, status, sql_command, message)
                    VALUES ('REVOKE_TABLES', v_role, v_schema, v_log_status, v_sql, 'Revoked existing table privs');
                    v_log := v_log || v_sql || E'\n';
                END IF;

                IF p_apply_to_existing_tables AND p_table_privileges IS NOT NULL THEN
                    FOREACH v_priv IN ARRAY p_table_privileges LOOP
                        v_sql := format('GRANT %s ON ALL TABLES IN SCHEMA %I TO %I;', v_priv, v_schema, v_role);
                        IF p_execute_flag THEN EXECUTE v_sql; END IF;
                        v_log_status := CASE WHEN p_execute_flag THEN 'EXECUTED' ELSE 'DRY_RUN' END;
                        INSERT INTO info.account_log_history (action_type, target_entity, associated_entity, status, sql_command, message)
                        VALUES ('GRANT_TABLES', v_role, v_schema, v_log_status, v_sql, 'Granted table privilege');
                        v_log := v_log || v_sql || E'\n';
                    END LOOP;
                END IF;

                IF p_function_privileges IS NOT NULL THEN
                    FOREACH v_priv IN ARRAY p_function_privileges LOOP
                        v_sql := format('GRANT %s ON ALL FUNCTIONS IN SCHEMA %I TO %I;', v_priv, v_schema, v_role);
                        IF p_execute_flag THEN EXECUTE v_sql; END IF;
                        v_log_status := CASE WHEN p_execute_flag THEN 'EXECUTED' ELSE 'DRY_RUN' END;
                        INSERT INTO info.account_log_history (action_type, target_entity, associated_entity, status, sql_command, message)
                        VALUES ('GRANT_FUNCTIONS', v_role, v_schema, v_log_status, v_sql, 'Granted function privilege');
                        v_log := v_log || v_sql || E'\n';
                    END LOOP;
                END IF;

                IF p_set_default_for_future_tables AND p_table_privileges IS NOT NULL THEN
                    FOREACH v_priv IN ARRAY p_table_privileges LOOP
                        v_sql := format('ALTER DEFAULT PRIVILEGES FOR ROLE dba_team IN SCHEMA %I GRANT %s ON TABLES TO %I;', v_schema, v_priv, v_role);
                        IF p_execute_flag THEN EXECUTE v_sql; END IF;
                        v_log_status := CASE WHEN p_execute_flag THEN 'EXECUTED' ELSE 'DRY_RUN' END;
                        INSERT INTO info.account_log_history (action_type, target_entity, associated_entity, status, sql_command, message)
                        VALUES ('DEFAULT_TABLES', v_role, v_schema, v_log_status, v_sql, 'Default table privilege set');
                        v_log := v_log || v_sql || E'\n';
                    END LOOP;
                END IF;

                IF p_set_default_for_future_functions AND p_function_privileges IS NOT NULL THEN
                    FOREACH v_priv IN ARRAY p_function_privileges LOOP
                        v_sql := format('ALTER DEFAULT PRIVILEGES FOR ROLE dba_team IN SCHEMA %I GRANT %s ON FUNCTIONS TO %I;', v_schema, v_priv, v_role);
                        IF p_execute_flag THEN EXECUTE v_sql; END IF;
                        v_log_status := CASE WHEN p_execute_flag THEN 'EXECUTED' ELSE 'DRY_RUN' END;
                        INSERT INTO info.account_log_history (action_type, target_entity, associated_entity, status, sql_command, message)
                        VALUES ('DEFAULT_FUNCTIONS', v_role, v_schema, v_log_status, v_sql, 'Default function privilege set');
                        v_log := v_log || v_sql || E'\n';
                    END LOOP;
                END IF;
            END LOOP;
        END IF;
    END LOOP;
    RETURN v_log;
END;
$$;

ALTER FUNCTION deploy.setrolepermissions(
    TEXT[], TEXT[], TEXT[], TEXT[], TEXT[],
    BOOLEAN, BOOLEAN, BOOLEAN, BOOLEAN, BOOLEAN
) OWNER TO dba_team;
--- END FAILED SCRIPT ---
üìÑ [DBA] /c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/2 deploy/deploy.createschemawithpermissions.sql
üîó Running: psql -U "jrussell" -h "dba-exp-tst.cluster-clm0vrvchewi.us-east-2.rds.amazonaws.com" -p "5432" -d DBA -f "/c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/2 deploy/deploy.createschemawithpermissions.sql"
psql: error: connection to server at "dba-exp-tst.cluster-clm0vrvchewi.us-east-2.rds.amazonaws.com" (172.31.24.19), port 5432 failed: FATAL:  database "DBA" does not exist
‚ùå ERROR running /c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/2 deploy/deploy.createschemawithpermissions.sql against DBA
--- FAILED COMMAND ---
psql -U "jrussell" -h "dba-exp-tst.cluster-clm0vrvchewi.us-east-2.rds.amazonaws.com" -p "5432" -d DBA -f "/c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/2 deploy/deploy.createschemawithpermissions.sql"
--- BEGIN FAILED SCRIPT: /c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/2 deploy/deploy.createschemawithpermissions.sql ---
-- FUNCTION: deploy.createschemawithpermissions(text, text, text[], boolean)
set role dba_team; 
-- DROP FUNCTION IF EXISTS deploy.createschemawithpermissions(text, text, text[], boolean);

CREATE OR REPLACE FUNCTION deploy.createschemawithpermissions(
	p_schema_name text,
	p_owner text,
	p_grant_roles text[] DEFAULT NULL::text[],
	p_execute_flag boolean DEFAULT false)
    RETURNS text
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
/*
============================================================
 USAGE EXAMPLES: deploy.CreateSchemaWithPermissions()
============================================================

-- √∞≈∏¬ß¬™ Dry-run mode
SELECT deploy.CreateSchemaWithPermissions(
    p_schema_name := 'audit',
    p_owner := 'jrussell',
    p_grant_roles := ARRAY['db_datareader', 'db_datawriter', 'db_ddladmin'],
    p_execute_flag := FALSE
);

--  Execute schema creation with role grants and default privileges
SELECT deploy.CreateSchemaWithPermissions(
    p_schema_name := 'audit',
    p_owner := 'jrussell',
    p_grant_roles := ARRAY['db_datareader', 'db_datawriter', 'db_ddladmin'],
    p_execute_flag := TRUE
);

-- Will skip creation if schema exists
SELECT deploy.CreateSchemaWithPermissions('public', 'postgres', ARRAY['readonly'], TRUE);
============================================================
*/

DECLARE
    v_exists BOOLEAN;
    v_sql TEXT;
    v_role TEXT;
    v_log_status TEXT;
BEGIN
    -- Check if schema already exists
    SELECT EXISTS (
        SELECT 1 FROM information_schema.schemata WHERE schema_name = p_schema_name
    ) INTO v_exists;

    IF v_exists THEN
        v_log_status := 'ALREADY_EXISTS';
        RAISE NOTICE 'Schema "%" already exists.', p_schema_name;

        INSERT INTO info.object_log_history (
            action_type, target_entity, associated_entity, status, sql_command, message
        ) VALUES (
            'CREATE_SCHEMA',
            p_schema_name,
            p_owner,
            v_log_status,
            NULL,
            'Schema already existed. No action taken.'
        );

        RETURN format('Schema "%s" already exists.', p_schema_name);
    END IF;

    --Create schema
    v_sql := format('CREATE SCHEMA %I AUTHORIZATION %I', p_schema_name, p_owner);
    RAISE NOTICE '[DRY-RUN] Would create schema: %', p_schema_name;

    IF p_execute_flag THEN
        EXECUTE v_sql;
        v_log_status := 'EXECUTED';
        RAISE NOTICE 'Schema "%" created.', p_schema_name;
    ELSE
        v_log_status := 'DRY_RUN';
    END IF;

    INSERT INTO info.object_log_history (
        action_type, target_entity, associated_entity, status, sql_command, message
    ) VALUES (
        'CREATE_SCHEMA',
        p_schema_name,
        p_owner,
        v_log_status,
        v_sql,
        'Schema creation completed.'
    );

    -- Grant USAGE on schema
    IF p_grant_roles IS NOT NULL THEN
        FOREACH v_role IN ARRAY p_grant_roles LOOP
            v_sql := format('GRANT USAGE ON SCHEMA %I TO %I', p_schema_name, v_role);

            IF p_execute_flag THEN
                EXECUTE v_sql;
                v_log_status := 'EXECUTED';
            ELSE
                v_log_status := 'DRY_RUN';
            END IF;

            INSERT INTO info.object_log_history (
                action_type, target_entity, associated_entity, status, sql_command, message
            ) VALUES (
                'GRANT_SCHEMA_USAGE',
                v_role,
                p_schema_name,
                v_log_status,
                v_sql,
                format('Granted USAGE on schema "%s" to "%s".', p_schema_name, v_role)
            );
        END LOOP;
    END IF;

    -- Set default privileges for future tables
    IF p_execute_flag THEN
        -- db_datareader: SELECT
        v_sql := format('ALTER DEFAULT PRIVILEGES FOR ROLE %I IN SCHEMA %I GRANT SELECT ON TABLES TO db_datareader', p_owner, p_schema_name);
        EXECUTE v_sql;
        INSERT INTO info.object_log_history VALUES (
            DEFAULT, now(), 'DEFAULT_PRIVS', p_schema_name, 'db_datareader', 'EXECUTED', v_sql,
            'Granted default SELECT privileges to db_datareader.');

        -- db_datawriter: INSERT/UPDATE/DELETE/SELECT
        v_sql := format('ALTER DEFAULT PRIVILEGES FOR ROLE %I IN SCHEMA %I GRANT DELETE, INSERT, SELECT, UPDATE ON TABLES TO db_datawriter', p_owner, p_schema_name);
        EXECUTE v_sql;
        INSERT INTO info.object_log_history VALUES (
            DEFAULT, now(), 'DEFAULT_PRIVS', p_schema_name, 'db_datawriter', 'EXECUTED', v_sql,
            'Granted default DML privileges to db_datawriter.');

        -- db_ddladmin: ALL
        v_sql := format('ALTER DEFAULT PRIVILEGES FOR ROLE %I IN SCHEMA %I GRANT ALL ON TABLES TO db_ddladmin', p_owner, p_schema_name);
        EXECUTE v_sql;
        INSERT INTO info.object_log_history VALUES (
            DEFAULT, now(), 'DEFAULT_PRIVS', p_schema_name, 'db_ddladmin', 'EXECUTED', v_sql,
            'Granted default ALL privileges to db_ddladmin.');
    END IF;

    RETURN format('Schema "%s" processed with usage and default table privileges.', p_schema_name);
END;
$BODY$;

ALTER FUNCTION deploy.createschemawithpermissions(text, text, text[], boolean)
    OWNER TO dba_team;
--- END FAILED SCRIPT ---
üìÑ [DBA] /c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/3 info/info.GetPrivileges.sql
üîó Running: psql -U "jrussell" -h "dba-exp-tst.cluster-clm0vrvchewi.us-east-2.rds.amazonaws.com" -p "5432" -d DBA -f "/c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/3 info/info.GetPrivileges.sql"
psql: error: connection to server at "dba-exp-tst.cluster-clm0vrvchewi.us-east-2.rds.amazonaws.com" (172.31.24.19), port 5432 failed: FATAL:  database "DBA" does not exist
‚ùå ERROR running /c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/3 info/info.GetPrivileges.sql against DBA
--- FAILED COMMAND ---
psql -U "jrussell" -h "dba-exp-tst.cluster-clm0vrvchewi.us-east-2.rds.amazonaws.com" -p "5432" -d DBA -f "/c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/3 info/info.GetPrivileges.sql"
--- BEGIN FAILED SCRIPT: /c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/3 info/info.GetPrivileges.sql ---
-- ============================================
-- Function: dynamic schema.GetPrivileges(p_role TEXT DEFAULT '')
-- Purpose: Retrieve role privileges across schemas and database
-- Version-safe: Includes default ACL parsing only if PG >= 140000
-- ============================================
set role dba_team;

DO $$
DECLARE
    v_sql TEXT;
    v_schema TEXT;
    v_version INT := current_setting('server_version_num')::INT;
BEGIN
    -- Determine the schema for the function based on the current database
    IF current_database() = 'DBA' THEN
        v_schema := 'info';
    ELSIF current_database() IN ('postgres', 'rdsadmin') THEN
        RAISE NOTICE 'Skipping function creation in system DB: %', current_database();
        RETURN; -- Exit if in a system database
    ELSE
        v_schema := 'dba';
    END IF;

    -- Construct the dynamic SQL for creating or replacing the function
    v_sql := '
    CREATE OR REPLACE FUNCTION ' || quote_ident(v_schema) || '.GetPrivileges(p_role TEXT DEFAULT '''')
    RETURNS TABLE (
        object_scope TEXT,
        grantee TEXT,
        privilege TEXT,
        inherited_role TEXT,
        source TEXT
    )
    LANGUAGE plpgsql AS
    $func$
    DECLARE
        v_ver INT := current_setting(''server_version_num'')::INT;
    BEGIN
        RETURN QUERY
        -- CTE to get roles and their directly inherited roles
        WITH inherited_roles AS (
            SELECT
                r.rolname AS role_name,
                string_agg(m.rolname, '','' ORDER BY m.rolname) AS inherited_role
            FROM pg_roles r
            LEFT JOIN pg_auth_members am ON r.oid = am.member
            LEFT JOIN pg_roles m ON am.roleid = m.oid
            GROUP BY r.rolname
        ),
        -- CTE for schema CREATE privileges
        schema_create AS (
            SELECT
                n.nspname::TEXT AS object_scope,
                r.rolname::TEXT AS grantee,
                ''CREATE''::TEXT AS privilege,
                ir.inherited_role,
                ''actual_schema_privilege''::TEXT AS source
            FROM pg_namespace n
            JOIN pg_roles r ON has_schema_privilege(r.rolname, n.oid, ''CREATE'')
            LEFT JOIN inherited_roles ir ON r.rolname = ir.role_name
            WHERE n.nspname NOT LIKE ''pg_%'' AND n.nspname <> ''information_schema''
        ),
        -- CTE for schema USAGE privileges
        schema_usage AS (
            SELECT
                n.nspname::TEXT AS object_scope,
                r.rolname::TEXT AS grantee,
                ''USAGE''::TEXT AS privilege,
                ir.inherited_role,
                ''actual_schema_privilege''::TEXT AS source
            FROM pg_namespace n
            JOIN pg_roles r ON has_schema_privilege(r.rolname, n.oid, ''USAGE'')
            LEFT JOIN inherited_roles ir ON r.rolname = ir.role_name
            WHERE n.nspname NOT LIKE ''pg_%'' AND n.nspname <> ''information_schema''
        ),
        -- CTE for database-level privileges (CREATE, TEMP, CONNECT)
        db_privs AS (
            SELECT
                current_database()::TEXT AS object_scope,
                r.rolname::TEXT AS grantee,
                unnest(string_to_array(
                    TRIM(BOTH '','' FROM
                        CASE WHEN has_database_privilege(r.rolname, current_database(), ''CREATE'') THEN ''CREATE,'' ELSE '''' END ||
                        CASE WHEN has_database_privilege(r.rolname, current_database(), ''TEMP'') THEN ''TEMP,'' ELSE '''' END ||
                        CASE WHEN has_database_privilege(r.rolname, current_database(), ''CONNECT'') THEN ''CONNECT'' ELSE '''' END
                    ), '',''))::TEXT AS privilege,
                ir.inherited_role,
                ''actual_database_privilege''::TEXT AS source
            FROM pg_roles r
            LEFT JOIN inherited_roles ir ON r.rolname = ir.role_name
        ),
        -- CTE to extract raw ACL entries from pg_default_acl for PG 14+
        raw_acls AS (
            SELECT
                pda.defaclnamespace::regnamespace::TEXT AS object_scope,
                (regexp_matches(acl_entry::TEXT, ''^(.+?)=([a-zA-Z]*)/?(.+)?$''))[1]::TEXT AS grantee,
                (regexp_matches(acl_entry::TEXT, ''^(.+?)=([a-zA-Z]*)/?(.+)?$''))[2]::TEXT AS privs_raw
            FROM pg_default_acl pda, unnest(pda.defaclacl) AS acl_entry
            WHERE current_setting(''server_version_num'')::INT >= 140000
        ),
        -- CTE to expand raw ACL characters into full privilege names
        expanded_acls AS (
            SELECT
                ra.object_scope,
                ra.grantee,
                CASE
                    WHEN ra.privs_raw IS NULL THEN NULL
                    ELSE array_to_string(ARRAY(
                        SELECT priv_subquery.privilege FROM (
                            SELECT CASE WHEN ra.privs_raw LIKE ''%a%'' THEN ''INSERT'' END AS privilege
                            UNION ALL SELECT CASE WHEN ra.privs_raw LIKE ''%r%'' THEN ''SELECT'' END
                            UNION ALL SELECT CASE WHEN ra.privs_raw LIKE ''%w%'' THEN ''UPDATE'' END
                            UNION ALL SELECT CASE WHEN ra.privs_raw LIKE ''%d%'' THEN ''DELETE'' END
                            UNION ALL SELECT CASE WHEN ra.privs_raw LIKE ''%D%'' THEN ''TRUNCATE'' END
                            UNION ALL SELECT CASE WHEN ra.privs_raw LIKE ''%x%'' THEN ''REFERENCES'' END
                            UNION ALL SELECT CASE WHEN ra.privs_raw LIKE ''%t%'' THEN ''TRIGGER'' END
                            UNION ALL SELECT CASE WHEN ra.privs_raw LIKE ''%X%'' THEN ''EXECUTE'' END
                        ) AS priv_subquery WHERE priv_subquery.privilege IS NOT NULL ORDER BY priv_subquery.privilege
                    ), '','')
                END AS privilege,
                ir.inherited_role,
                ''default_acl''::TEXT AS source
            FROM raw_acls ra
            LEFT JOIN inherited_roles ir ON ra.grantee = ir.role_name
        )

        -- Combine all privilege types and filter by p_role if provided
        SELECT sc.object_scope, sc.grantee, sc.privilege, sc.inherited_role, sc.source FROM schema_create sc WHERE p_role = '''' OR sc.grantee = p_role
        UNION ALL
        SELECT su.object_scope, su.grantee, su.privilege, su.inherited_role, su.source FROM schema_usage su WHERE p_role = '''' OR su.grantee = p_role
        UNION ALL
        SELECT db.object_scope, db.grantee, db.privilege, db.inherited_role, db.source FROM db_privs db WHERE p_role = '''' OR db.grantee = p_role
        UNION ALL
        SELECT ea.object_scope, ea.grantee, ea.privilege, ea.inherited_role, ea.source FROM expanded_acls ea WHERE p_role = '''' OR ea.grantee = p_role
        ORDER BY grantee, object_scope, privilege;
    END;
    $func$;
    ';

    -- Execute the dynamically constructed SQL to create the function
    EXECUTE v_sql;
END $$;
--- END FAILED SCRIPT ---
üìÑ [DBA] /c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/3 info/info.SetPassword.sql
üîó Running: psql -U "jrussell" -h "dba-exp-tst.cluster-clm0vrvchewi.us-east-2.rds.amazonaws.com" -p "5432" -d DBA -f "/c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/3 info/info.SetPassword.sql"
psql: error: connection to server at "dba-exp-tst.cluster-clm0vrvchewi.us-east-2.rds.amazonaws.com" (172.31.24.19), port 5432 failed: FATAL:  database "DBA" does not exist
‚ùå ERROR running /c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/3 info/info.SetPassword.sql against DBA
--- FAILED COMMAND ---
psql -U "jrussell" -h "dba-exp-tst.cluster-clm0vrvchewi.us-east-2.rds.amazonaws.com" -p "5432" -d DBA -f "/c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/3 info/info.SetPassword.sql"
--- BEGIN FAILED SCRIPT: /c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/3 info/info.SetPassword.sql ---
-- ‚úÖ PostgreSQL-Compatible Password Audit Setup
-- Filename: 13_info.SetPassword_FIXED.sql

-- ============================================================
-- STEP 1: Ensure info schema exists
-- ============================================================
set role dba_team; 


DO $$
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM pg_namespace WHERE nspname = 'info'
    ) THEN
        EXECUTE 'CREATE SCHEMA info AUTHORIZATION current_user';
        RAISE NOTICE 'Schema "info" created.';
    ELSE
        RAISE NOTICE 'Schema "info" already exists.';
    END IF;
END
$$;

-- ============================================================
-- STEP 2: Create info.password_change_audit table safely
-- ============================================================

DO $$
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.tables 
        WHERE table_schema = 'info' AND table_name = 'password_change_audit'
    ) THEN
        CREATE TABLE info.password_change_audit (
            audit_id SERIAL PRIMARY KEY,
            changed_at TIMESTAMPTZ DEFAULT now(),
            changed_by TEXT NOT NULL,
            changed_user TEXT NOT NULL,
            note TEXT
        );

        ALTER TABLE info.password_change_audit OWNER TO dba_team;

        REVOKE ALL ON TABLE info.password_change_audit FROM db_datareader;
        REVOKE ALL ON TABLE info.password_change_audit FROM db_datawriter;

        GRANT SELECT ON TABLE info.password_change_audit TO db_datareader;
        GRANT INSERT, SELECT, UPDATE, DELETE ON TABLE info.password_change_audit TO db_datawriter;
        GRANT ALL ON TABLE info.password_change_audit TO db_ddladmin;
        GRANT ALL ON TABLE info.password_change_audit TO dba_team;

        RAISE NOTICE 'Table "info.password_change_audit" created.';
    ELSE
        RAISE NOTICE 'Table "info.password_change_audit" already exists.';
    END IF;
END
$$;

-- ============================================================
-- STEP 3: Create SetPassword Function
-- ============================================================

CREATE OR REPLACE FUNCTION info.SetPassword(
    target_username TEXT,
    new_password TEXT
)
RETURNS VOID AS
$$
DECLARE
    caller TEXT := session_user;
BEGIN
    -- Input validation
    IF target_username IS NULL OR trim(target_username) = '' THEN
        RAISE EXCEPTION 'Username cannot be null or empty';
    END IF;

    IF new_password IS NULL OR trim(new_password) = '' THEN
        RAISE EXCEPTION 'Password cannot be null or empty';
    END IF;

    IF length(new_password) < 9 THEN
        RAISE EXCEPTION 'Password must be at least 12 characters long';
    END IF;

    IF lower(target_username) = 'postgres' THEN
        RAISE EXCEPTION 'Changing password for superuser "postgres" is not allowed through this function';
    END IF;

    -- Explicit check for user existence
    IF EXISTS (SELECT 1 FROM pg_roles WHERE rolname = target_username) THEN
        EXECUTE format('ALTER ROLE %I WITH PASSWORD %L', target_username, new_password);

        INSERT INTO info.password_change_audit (changed_by, changed_user, note)
        VALUES (caller, target_username, 'Password changed via info.safe_change_password');

        RAISE NOTICE 'SUCCESS: Password changed for user %', target_username;
    ELSE
        RAISE EXCEPTION 'User "%" does not exist', target_username;
    END IF;
END;
$$
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = info, public;

-- Helper usage reminder
DO $$
BEGIN
    RAISE NOTICE 'To execute password change: SELECT info.SetPassword(''username'', ''newPassword'');';
END
$$ LANGUAGE plpgsql;
--- END FAILED SCRIPT ---
üìÑ [DBA] /c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/3 info/info.sp_whoisactive.sql
üîó Running: psql -U "jrussell" -h "dba-exp-tst.cluster-clm0vrvchewi.us-east-2.rds.amazonaws.com" -p "5432" -d DBA -f "/c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/3 info/info.sp_whoisactive.sql"
psql: error: connection to server at "dba-exp-tst.cluster-clm0vrvchewi.us-east-2.rds.amazonaws.com" (172.31.24.19), port 5432 failed: FATAL:  database "DBA" does not exist
‚ùå ERROR running /c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/3 info/info.sp_whoisactive.sql against DBA
--- FAILED COMMAND ---
psql -U "jrussell" -h "dba-exp-tst.cluster-clm0vrvchewi.us-east-2.rds.amazonaws.com" -p "5432" -d DBA -f "/c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/3 info/info.sp_whoisactive.sql"
--- BEGIN FAILED SCRIPT: /c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/3 info/info.sp_whoisactive.sql ---
set role dba_team; 


CREATE OR REPLACE FUNCTION info.sp_whoisactive (
    p_database_name TEXT DEFAULT NULL,
    p_show_idle_in_transaction BOOLEAN DEFAULT FALSE,
    p_show_all_idle BOOLEAN DEFAULT FALSE
)
RETURNS TABLE (
    duration INTERVAL,
    pid INT,
    datname NAME,
    usename NAME,
    application_name TEXT,
    client_addr INET,
    backend_start TIMESTAMPTZ,
    xact_start TIMESTAMPTZ,
    query_start TIMESTAMPTZ,
    state_change TIMESTAMPTZ,
    state TEXT,
    wait_event_type TEXT,
    wait_event TEXT,
    query TEXT
)
LANGUAGE plpgsql
AS $$
BEGIN
    RETURN QUERY
    SELECT
        NOW() - sa.query_start AS duration,
        sa.pid,
        sa.datname,
        sa.usename,
        sa.application_name,
        sa.client_addr,
        sa.backend_start,
        sa.xact_start,
        sa.query_start,
        sa.state_change,
        sa.state,
        sa.wait_event_type,
        sa.wait_event,
        sa.query
    FROM
        pg_stat_activity sa
    WHERE
        sa.pid <> pg_backend_pid()
        AND (
            p_show_all_idle
            OR
            (
                NOT p_show_all_idle AND NOT p_show_idle_in_transaction AND sa.state <> 'idle'
            )
            OR
            (
                NOT p_show_all_idle AND p_show_idle_in_transaction AND sa.state <> 'idle' OR sa.state ILIKE 'idle in transaction%'
            )
        )
        AND (p_database_name IS NULL OR sa.datname = p_database_name)
    ORDER BY
        sa.query_start DESC;
END;
$$;--- END FAILED SCRIPT ---
üìÑ [DBA] /c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/4 admin/admin.SetDBOffline.sql
üîó Running: psql -U "jrussell" -h "dba-exp-tst.cluster-clm0vrvchewi.us-east-2.rds.amazonaws.com" -p "5432" -d DBA -f "/c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/4 admin/admin.SetDBOffline.sql"
psql: error: connection to server at "dba-exp-tst.cluster-clm0vrvchewi.us-east-2.rds.amazonaws.com" (172.31.24.19), port 5432 failed: FATAL:  database "DBA" does not exist
‚ùå ERROR running /c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/4 admin/admin.SetDBOffline.sql against DBA
--- FAILED COMMAND ---
psql -U "jrussell" -h "dba-exp-tst.cluster-clm0vrvchewi.us-east-2.rds.amazonaws.com" -p "5432" -d DBA -f "/c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/4 admin/admin.SetDBOffline.sql"
--- BEGIN FAILED SCRIPT: /c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/4 admin/admin.SetDBOffline.sql ---
-- ================================================
-- FUNCTION: admin.SetDatabaseConnectionLimit
-- PURPOSE: Set a database's connection limit and log the change
-- ================================================
set role dba_team; 

CREATE OR REPLACE FUNCTION admin.SetDBOffline(
    target_db TEXT,
    connection_limit INT
)
RETURNS TEXT
LANGUAGE plpgsql
AS $$
DECLARE
    action_label TEXT;
    status_label TEXT := 'SUCCESS';
    command_executed TEXT;
BEGIN
    -- Build the SQL command
    command_executed := format('ALTER DATABASE %I CONNECTION LIMIT %s;', target_db, connection_limit);
    EXECUTE command_executed;

    -- Define action type
    action_label := CASE
        WHEN connection_limit = 0 THEN 'Set DB Offline'
        WHEN connection_limit = -1 THEN 'Set DB Online'
        ELSE 'Set DB Conn Limit: ' || connection_limit::TEXT
    END;

    -- Log the event
    INSERT INTO info.object_log_history (
        action_type,
        target_entity,
        associated_entity,
        status,
        sql_command,
        message
    )
    VALUES (
        action_label,
        target_db,
        current_user,
        status_label,
        command_executed,
        format('Connection limit set to %s', connection_limit)
    );

    RETURN format('Database %s connection limit set to %s', target_db, connection_limit);
END $$;
--- END FAILED SCRIPT ---
üîÅ Running on pg_poc...
üìÑ [pg_poc] /c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/5 other/dba.GetPrivileges.sql
üîó Running: psql -U "jrussell" -h "dba-exp-tst.cluster-clm0vrvchewi.us-east-2.rds.amazonaws.com" -p "5432" -d "pg_poc" -f "/c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/5 other/dba.GetPrivileges.sql"
psql: error: connection to server at "dba-exp-tst.cluster-clm0vrvchewi.us-east-2.rds.amazonaws.com" (172.31.24.19), port 5432 failed: FATAL:  database "pg_poc" does not exist
‚ùå ERROR running /c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/5 other/dba.GetPrivileges.sql against pg_poc
--- FAILED COMMAND ---
psql -U "jrussell" -h "dba-exp-tst.cluster-clm0vrvchewi.us-east-2.rds.amazonaws.com" -p "5432" -d "pg_poc" -f "/c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/5 other/dba.GetPrivileges.sql"
--- BEGIN FAILED SCRIPT: /c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/5 other/dba.GetPrivileges.sql ---
-- ============================================
-- Function: dynamic schema.GetPrivileges(p_role TEXT DEFAULT '')
-- Purpose: Retrieve role privileges across schemas and database
-- Version-safe: Includes default ACL parsing only if PG >= 140000
-- ============================================
set role dba_team; 

DO $$
DECLARE
    v_sql TEXT;
    v_schema TEXT;
    v_version INT := current_setting('server_version_num')::INT;
BEGIN
    -- Determine the schema for the function based on the current database
    IF current_database() = 'DBA' THEN
        v_schema := 'info';
    ELSIF current_database() IN ('postgres', 'rdsadmin') THEN
        RAISE NOTICE 'Skipping function creation in system DB: %', current_database();
        RETURN; -- Exit if in a system database
    ELSE
        v_schema := 'dba';
    END IF;

    -- Construct the dynamic SQL for creating or replacing the function
    v_sql := '
    CREATE OR REPLACE FUNCTION ' || quote_ident(v_schema) || '.GetPrivileges(p_role TEXT DEFAULT '''')
    RETURNS TABLE (
        object_scope TEXT,
        grantee TEXT,
        privilege TEXT,
        inherited_role TEXT,
        source TEXT
    )
    LANGUAGE plpgsql AS
    $func$
    DECLARE
        v_ver INT := current_setting(''server_version_num'')::INT;
    BEGIN
        RETURN QUERY
        -- CTE to get roles and their directly inherited roles
        WITH inherited_roles AS (
            SELECT
                r.rolname AS role_name,
                string_agg(m.rolname, '','' ORDER BY m.rolname) AS inherited_role
            FROM pg_roles r
            LEFT JOIN pg_auth_members am ON r.oid = am.member
            LEFT JOIN pg_roles m ON am.roleid = m.oid
            GROUP BY r.rolname
        ),
        -- CTE for schema CREATE privileges
        schema_create AS (
            SELECT
                n.nspname::TEXT AS object_scope,
                r.rolname::TEXT AS grantee,
                ''CREATE''::TEXT AS privilege,
                ir.inherited_role,
                ''actual_schema_privilege''::TEXT AS source
            FROM pg_namespace n
            JOIN pg_roles r ON has_schema_privilege(r.rolname, n.oid, ''CREATE'')
            LEFT JOIN inherited_roles ir ON r.rolname = ir.role_name
            WHERE n.nspname NOT LIKE ''pg_%'' AND n.nspname <> ''information_schema''
        ),
        -- CTE for schema USAGE privileges
        schema_usage AS (
            SELECT
                n.nspname::TEXT AS object_scope,
                r.rolname::TEXT AS grantee,
                ''USAGE''::TEXT AS privilege,
                ir.inherited_role,
                ''actual_schema_privilege''::TEXT AS source
            FROM pg_namespace n
            JOIN pg_roles r ON has_schema_privilege(r.rolname, n.oid, ''USAGE'')
            LEFT JOIN inherited_roles ir ON r.rolname = ir.role_name
            WHERE n.nspname NOT LIKE ''pg_%'' AND n.nspname <> ''information_schema''
        ),
        -- CTE for database-level privileges (CREATE, TEMP, CONNECT)
        db_privs AS (
            SELECT
                current_database()::TEXT AS object_scope,
                r.rolname::TEXT AS grantee,
                unnest(string_to_array(
                    TRIM(BOTH '','' FROM
                        CASE WHEN has_database_privilege(r.rolname, current_database(), ''CREATE'') THEN ''CREATE,'' ELSE '''' END ||
                        CASE WHEN has_database_privilege(r.rolname, current_database(), ''TEMP'') THEN ''TEMP,'' ELSE '''' END ||
                        CASE WHEN has_database_privilege(r.rolname, current_database(), ''CONNECT'') THEN ''CONNECT'' ELSE '''' END
                    ), '',''))::TEXT AS privilege,
                ir.inherited_role,
                ''actual_database_privilege''::TEXT AS source
            FROM pg_roles r
            LEFT JOIN inherited_roles ir ON r.rolname = ir.role_name
        ),
        -- CTE to extract raw ACL entries from pg_default_acl for PG 14+
        raw_acls AS (
            SELECT
                pda.defaclnamespace::regnamespace::TEXT AS object_scope,
                (regexp_matches(acl_entry::TEXT, ''^(.+?)=([a-zA-Z]*)/?(.+)?$''))[1]::TEXT AS grantee,
                (regexp_matches(acl_entry::TEXT, ''^(.+?)=([a-zA-Z]*)/?(.+)?$''))[2]::TEXT AS privs_raw
            FROM pg_default_acl pda, unnest(pda.defaclacl) AS acl_entry
            WHERE current_setting(''server_version_num'')::INT >= 140000
        ),
        -- CTE to expand raw ACL characters into full privilege names
        expanded_acls AS (
            SELECT
                ra.object_scope,
                ra.grantee,
                CASE
                    WHEN ra.privs_raw IS NULL THEN NULL
                    ELSE array_to_string(ARRAY(
                        SELECT priv_subquery.privilege FROM (
                            SELECT CASE WHEN ra.privs_raw LIKE ''%a%'' THEN ''INSERT'' END AS privilege
                            UNION ALL SELECT CASE WHEN ra.privs_raw LIKE ''%r%'' THEN ''SELECT'' END
                            UNION ALL SELECT CASE WHEN ra.privs_raw LIKE ''%w%'' THEN ''UPDATE'' END
                            UNION ALL SELECT CASE WHEN ra.privs_raw LIKE ''%d%'' THEN ''DELETE'' END
                            UNION ALL SELECT CASE WHEN ra.privs_raw LIKE ''%D%'' THEN ''TRUNCATE'' END
                            UNION ALL SELECT CASE WHEN ra.privs_raw LIKE ''%x%'' THEN ''REFERENCES'' END
                            UNION ALL SELECT CASE WHEN ra.privs_raw LIKE ''%t%'' THEN ''TRIGGER'' END
                            UNION ALL SELECT CASE WHEN ra.privs_raw LIKE ''%X%'' THEN ''EXECUTE'' END
                        ) AS priv_subquery WHERE priv_subquery.privilege IS NOT NULL ORDER BY priv_subquery.privilege
                    ), '','')
                END AS privilege,
                ir.inherited_role,
                ''default_acl''::TEXT AS source
            FROM raw_acls ra
            LEFT JOIN inherited_roles ir ON ra.grantee = ir.role_name
        )

        -- Combine all privilege types and filter by p_role if provided
        SELECT sc.object_scope, sc.grantee, sc.privilege, sc.inherited_role, sc.source FROM schema_create sc WHERE p_role = '''' OR sc.grantee = p_role
        UNION ALL
        SELECT su.object_scope, su.grantee, su.privilege, su.inherited_role, su.source FROM schema_usage su WHERE p_role = '''' OR su.grantee = p_role
        UNION ALL
        SELECT db.object_scope, db.grantee, db.privilege, db.inherited_role, db.source FROM db_privs db WHERE p_role = '''' OR db.grantee = p_role
        UNION ALL
        SELECT ea.object_scope, ea.grantee, ea.privilege, ea.inherited_role, ea.source FROM expanded_acls ea WHERE p_role = '''' OR ea.grantee = p_role
        ORDER BY grantee, object_scope, privilege;
    END;
    $func$;
    ';

    -- Execute the dynamically constructed SQL to create the function
    EXECUTE v_sql;
END $$;
--- END FAILED SCRIPT ---
üîÅ Running on whatup...
üìÑ [whatup] /c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/5 other/dba.GetPrivileges.sql
üîó Running: psql -U "jrussell" -h "dba-exp-tst.cluster-clm0vrvchewi.us-east-2.rds.amazonaws.com" -p "5432" -d "whatup" -f "/c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/5 other/dba.GetPrivileges.sql"
psql: error: connection to server at "dba-exp-tst.cluster-clm0vrvchewi.us-east-2.rds.amazonaws.com" (172.31.24.19), port 5432 failed: FATAL:  database "whatup" does not exist
‚ùå ERROR running /c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/5 other/dba.GetPrivileges.sql against whatup
--- FAILED COMMAND ---
psql -U "jrussell" -h "dba-exp-tst.cluster-clm0vrvchewi.us-east-2.rds.amazonaws.com" -p "5432" -d "whatup" -f "/c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/5 other/dba.GetPrivileges.sql"
--- BEGIN FAILED SCRIPT: /c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/5 other/dba.GetPrivileges.sql ---
-- ============================================
-- Function: dynamic schema.GetPrivileges(p_role TEXT DEFAULT '')
-- Purpose: Retrieve role privileges across schemas and database
-- Version-safe: Includes default ACL parsing only if PG >= 140000
-- ============================================
set role dba_team; 

DO $$
DECLARE
    v_sql TEXT;
    v_schema TEXT;
    v_version INT := current_setting('server_version_num')::INT;
BEGIN
    -- Determine the schema for the function based on the current database
    IF current_database() = 'DBA' THEN
        v_schema := 'info';
    ELSIF current_database() IN ('postgres', 'rdsadmin') THEN
        RAISE NOTICE 'Skipping function creation in system DB: %', current_database();
        RETURN; -- Exit if in a system database
    ELSE
        v_schema := 'dba';
    END IF;

    -- Construct the dynamic SQL for creating or replacing the function
    v_sql := '
    CREATE OR REPLACE FUNCTION ' || quote_ident(v_schema) || '.GetPrivileges(p_role TEXT DEFAULT '''')
    RETURNS TABLE (
        object_scope TEXT,
        grantee TEXT,
        privilege TEXT,
        inherited_role TEXT,
        source TEXT
    )
    LANGUAGE plpgsql AS
    $func$
    DECLARE
        v_ver INT := current_setting(''server_version_num'')::INT;
    BEGIN
        RETURN QUERY
        -- CTE to get roles and their directly inherited roles
        WITH inherited_roles AS (
            SELECT
                r.rolname AS role_name,
                string_agg(m.rolname, '','' ORDER BY m.rolname) AS inherited_role
            FROM pg_roles r
            LEFT JOIN pg_auth_members am ON r.oid = am.member
            LEFT JOIN pg_roles m ON am.roleid = m.oid
            GROUP BY r.rolname
        ),
        -- CTE for schema CREATE privileges
        schema_create AS (
            SELECT
                n.nspname::TEXT AS object_scope,
                r.rolname::TEXT AS grantee,
                ''CREATE''::TEXT AS privilege,
                ir.inherited_role,
                ''actual_schema_privilege''::TEXT AS source
            FROM pg_namespace n
            JOIN pg_roles r ON has_schema_privilege(r.rolname, n.oid, ''CREATE'')
            LEFT JOIN inherited_roles ir ON r.rolname = ir.role_name
            WHERE n.nspname NOT LIKE ''pg_%'' AND n.nspname <> ''information_schema''
        ),
        -- CTE for schema USAGE privileges
        schema_usage AS (
            SELECT
                n.nspname::TEXT AS object_scope,
                r.rolname::TEXT AS grantee,
                ''USAGE''::TEXT AS privilege,
                ir.inherited_role,
                ''actual_schema_privilege''::TEXT AS source
            FROM pg_namespace n
            JOIN pg_roles r ON has_schema_privilege(r.rolname, n.oid, ''USAGE'')
            LEFT JOIN inherited_roles ir ON r.rolname = ir.role_name
            WHERE n.nspname NOT LIKE ''pg_%'' AND n.nspname <> ''information_schema''
        ),
        -- CTE for database-level privileges (CREATE, TEMP, CONNECT)
        db_privs AS (
            SELECT
                current_database()::TEXT AS object_scope,
                r.rolname::TEXT AS grantee,
                unnest(string_to_array(
                    TRIM(BOTH '','' FROM
                        CASE WHEN has_database_privilege(r.rolname, current_database(), ''CREATE'') THEN ''CREATE,'' ELSE '''' END ||
                        CASE WHEN has_database_privilege(r.rolname, current_database(), ''TEMP'') THEN ''TEMP,'' ELSE '''' END ||
                        CASE WHEN has_database_privilege(r.rolname, current_database(), ''CONNECT'') THEN ''CONNECT'' ELSE '''' END
                    ), '',''))::TEXT AS privilege,
                ir.inherited_role,
                ''actual_database_privilege''::TEXT AS source
            FROM pg_roles r
            LEFT JOIN inherited_roles ir ON r.rolname = ir.role_name
        ),
        -- CTE to extract raw ACL entries from pg_default_acl for PG 14+
        raw_acls AS (
            SELECT
                pda.defaclnamespace::regnamespace::TEXT AS object_scope,
                (regexp_matches(acl_entry::TEXT, ''^(.+?)=([a-zA-Z]*)/?(.+)?$''))[1]::TEXT AS grantee,
                (regexp_matches(acl_entry::TEXT, ''^(.+?)=([a-zA-Z]*)/?(.+)?$''))[2]::TEXT AS privs_raw
            FROM pg_default_acl pda, unnest(pda.defaclacl) AS acl_entry
            WHERE current_setting(''server_version_num'')::INT >= 140000
        ),
        -- CTE to expand raw ACL characters into full privilege names
        expanded_acls AS (
            SELECT
                ra.object_scope,
                ra.grantee,
                CASE
                    WHEN ra.privs_raw IS NULL THEN NULL
                    ELSE array_to_string(ARRAY(
                        SELECT priv_subquery.privilege FROM (
                            SELECT CASE WHEN ra.privs_raw LIKE ''%a%'' THEN ''INSERT'' END AS privilege
                            UNION ALL SELECT CASE WHEN ra.privs_raw LIKE ''%r%'' THEN ''SELECT'' END
                            UNION ALL SELECT CASE WHEN ra.privs_raw LIKE ''%w%'' THEN ''UPDATE'' END
                            UNION ALL SELECT CASE WHEN ra.privs_raw LIKE ''%d%'' THEN ''DELETE'' END
                            UNION ALL SELECT CASE WHEN ra.privs_raw LIKE ''%D%'' THEN ''TRUNCATE'' END
                            UNION ALL SELECT CASE WHEN ra.privs_raw LIKE ''%x%'' THEN ''REFERENCES'' END
                            UNION ALL SELECT CASE WHEN ra.privs_raw LIKE ''%t%'' THEN ''TRIGGER'' END
                            UNION ALL SELECT CASE WHEN ra.privs_raw LIKE ''%X%'' THEN ''EXECUTE'' END
                        ) AS priv_subquery WHERE priv_subquery.privilege IS NOT NULL ORDER BY priv_subquery.privilege
                    ), '','')
                END AS privilege,
                ir.inherited_role,
                ''default_acl''::TEXT AS source
            FROM raw_acls ra
            LEFT JOIN inherited_roles ir ON ra.grantee = ir.role_name
        )

        -- Combine all privilege types and filter by p_role if provided
        SELECT sc.object_scope, sc.grantee, sc.privilege, sc.inherited_role, sc.source FROM schema_create sc WHERE p_role = '''' OR sc.grantee = p_role
        UNION ALL
        SELECT su.object_scope, su.grantee, su.privilege, su.inherited_role, su.source FROM schema_usage su WHERE p_role = '''' OR su.grantee = p_role
        UNION ALL
        SELECT db.object_scope, db.grantee, db.privilege, db.inherited_role, db.source FROM db_privs db WHERE p_role = '''' OR db.grantee = p_role
        UNION ALL
        SELECT ea.object_scope, ea.grantee, ea.privilege, ea.inherited_role, ea.source FROM expanded_acls ea WHERE p_role = '''' OR ea.grantee = p_role
        ORDER BY grantee, object_scope, privilege;
    END;
    $func$;
    ';

    -- Execute the dynamically constructed SQL to create the function
    EXECUTE v_sql;
END $$;
--- END FAILED SCRIPT ---
üîÅ Running on pg_poc_restore...
üìÑ [pg_poc_restore] /c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/5 other/dba.GetPrivileges.sql
üîó Running: psql -U "jrussell" -h "dba-exp-tst.cluster-clm0vrvchewi.us-east-2.rds.amazonaws.com" -p "5432" -d "pg_poc_restore" -f "/c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/5 other/dba.GetPrivileges.sql"
psql: error: connection to server at "dba-exp-tst.cluster-clm0vrvchewi.us-east-2.rds.amazonaws.com" (172.31.24.19), port 5432 failed: FATAL:  database "pg_poc_restore" does not exist
‚ùå ERROR running /c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/5 other/dba.GetPrivileges.sql against pg_poc_restore
--- FAILED COMMAND ---
psql -U "jrussell" -h "dba-exp-tst.cluster-clm0vrvchewi.us-east-2.rds.amazonaws.com" -p "5432" -d "pg_poc_restore" -f "/c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/5 other/dba.GetPrivileges.sql"
--- BEGIN FAILED SCRIPT: /c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/5 other/dba.GetPrivileges.sql ---
-- ============================================
-- Function: dynamic schema.GetPrivileges(p_role TEXT DEFAULT '')
-- Purpose: Retrieve role privileges across schemas and database
-- Version-safe: Includes default ACL parsing only if PG >= 140000
-- ============================================
set role dba_team; 

DO $$
DECLARE
    v_sql TEXT;
    v_schema TEXT;
    v_version INT := current_setting('server_version_num')::INT;
BEGIN
    -- Determine the schema for the function based on the current database
    IF current_database() = 'DBA' THEN
        v_schema := 'info';
    ELSIF current_database() IN ('postgres', 'rdsadmin') THEN
        RAISE NOTICE 'Skipping function creation in system DB: %', current_database();
        RETURN; -- Exit if in a system database
    ELSE
        v_schema := 'dba';
    END IF;

    -- Construct the dynamic SQL for creating or replacing the function
    v_sql := '
    CREATE OR REPLACE FUNCTION ' || quote_ident(v_schema) || '.GetPrivileges(p_role TEXT DEFAULT '''')
    RETURNS TABLE (
        object_scope TEXT,
        grantee TEXT,
        privilege TEXT,
        inherited_role TEXT,
        source TEXT
    )
    LANGUAGE plpgsql AS
    $func$
    DECLARE
        v_ver INT := current_setting(''server_version_num'')::INT;
    BEGIN
        RETURN QUERY
        -- CTE to get roles and their directly inherited roles
        WITH inherited_roles AS (
            SELECT
                r.rolname AS role_name,
                string_agg(m.rolname, '','' ORDER BY m.rolname) AS inherited_role
            FROM pg_roles r
            LEFT JOIN pg_auth_members am ON r.oid = am.member
            LEFT JOIN pg_roles m ON am.roleid = m.oid
            GROUP BY r.rolname
        ),
        -- CTE for schema CREATE privileges
        schema_create AS (
            SELECT
                n.nspname::TEXT AS object_scope,
                r.rolname::TEXT AS grantee,
                ''CREATE''::TEXT AS privilege,
                ir.inherited_role,
                ''actual_schema_privilege''::TEXT AS source
            FROM pg_namespace n
            JOIN pg_roles r ON has_schema_privilege(r.rolname, n.oid, ''CREATE'')
            LEFT JOIN inherited_roles ir ON r.rolname = ir.role_name
            WHERE n.nspname NOT LIKE ''pg_%'' AND n.nspname <> ''information_schema''
        ),
        -- CTE for schema USAGE privileges
        schema_usage AS (
            SELECT
                n.nspname::TEXT AS object_scope,
                r.rolname::TEXT AS grantee,
                ''USAGE''::TEXT AS privilege,
                ir.inherited_role,
                ''actual_schema_privilege''::TEXT AS source
            FROM pg_namespace n
            JOIN pg_roles r ON has_schema_privilege(r.rolname, n.oid, ''USAGE'')
            LEFT JOIN inherited_roles ir ON r.rolname = ir.role_name
            WHERE n.nspname NOT LIKE ''pg_%'' AND n.nspname <> ''information_schema''
        ),
        -- CTE for database-level privileges (CREATE, TEMP, CONNECT)
        db_privs AS (
            SELECT
                current_database()::TEXT AS object_scope,
                r.rolname::TEXT AS grantee,
                unnest(string_to_array(
                    TRIM(BOTH '','' FROM
                        CASE WHEN has_database_privilege(r.rolname, current_database(), ''CREATE'') THEN ''CREATE,'' ELSE '''' END ||
                        CASE WHEN has_database_privilege(r.rolname, current_database(), ''TEMP'') THEN ''TEMP,'' ELSE '''' END ||
                        CASE WHEN has_database_privilege(r.rolname, current_database(), ''CONNECT'') THEN ''CONNECT'' ELSE '''' END
                    ), '',''))::TEXT AS privilege,
                ir.inherited_role,
                ''actual_database_privilege''::TEXT AS source
            FROM pg_roles r
            LEFT JOIN inherited_roles ir ON r.rolname = ir.role_name
        ),
        -- CTE to extract raw ACL entries from pg_default_acl for PG 14+
        raw_acls AS (
            SELECT
                pda.defaclnamespace::regnamespace::TEXT AS object_scope,
                (regexp_matches(acl_entry::TEXT, ''^(.+?)=([a-zA-Z]*)/?(.+)?$''))[1]::TEXT AS grantee,
                (regexp_matches(acl_entry::TEXT, ''^(.+?)=([a-zA-Z]*)/?(.+)?$''))[2]::TEXT AS privs_raw
            FROM pg_default_acl pda, unnest(pda.defaclacl) AS acl_entry
            WHERE current_setting(''server_version_num'')::INT >= 140000
        ),
        -- CTE to expand raw ACL characters into full privilege names
        expanded_acls AS (
            SELECT
                ra.object_scope,
                ra.grantee,
                CASE
                    WHEN ra.privs_raw IS NULL THEN NULL
                    ELSE array_to_string(ARRAY(
                        SELECT priv_subquery.privilege FROM (
                            SELECT CASE WHEN ra.privs_raw LIKE ''%a%'' THEN ''INSERT'' END AS privilege
                            UNION ALL SELECT CASE WHEN ra.privs_raw LIKE ''%r%'' THEN ''SELECT'' END
                            UNION ALL SELECT CASE WHEN ra.privs_raw LIKE ''%w%'' THEN ''UPDATE'' END
                            UNION ALL SELECT CASE WHEN ra.privs_raw LIKE ''%d%'' THEN ''DELETE'' END
                            UNION ALL SELECT CASE WHEN ra.privs_raw LIKE ''%D%'' THEN ''TRUNCATE'' END
                            UNION ALL SELECT CASE WHEN ra.privs_raw LIKE ''%x%'' THEN ''REFERENCES'' END
                            UNION ALL SELECT CASE WHEN ra.privs_raw LIKE ''%t%'' THEN ''TRIGGER'' END
                            UNION ALL SELECT CASE WHEN ra.privs_raw LIKE ''%X%'' THEN ''EXECUTE'' END
                        ) AS priv_subquery WHERE priv_subquery.privilege IS NOT NULL ORDER BY priv_subquery.privilege
                    ), '','')
                END AS privilege,
                ir.inherited_role,
                ''default_acl''::TEXT AS source
            FROM raw_acls ra
            LEFT JOIN inherited_roles ir ON ra.grantee = ir.role_name
        )

        -- Combine all privilege types and filter by p_role if provided
        SELECT sc.object_scope, sc.grantee, sc.privilege, sc.inherited_role, sc.source FROM schema_create sc WHERE p_role = '''' OR sc.grantee = p_role
        UNION ALL
        SELECT su.object_scope, su.grantee, su.privilege, su.inherited_role, su.source FROM schema_usage su WHERE p_role = '''' OR su.grantee = p_role
        UNION ALL
        SELECT db.object_scope, db.grantee, db.privilege, db.inherited_role, db.source FROM db_privs db WHERE p_role = '''' OR db.grantee = p_role
        UNION ALL
        SELECT ea.object_scope, ea.grantee, ea.privilege, ea.inherited_role, ea.source FROM expanded_acls ea WHERE p_role = '''' OR ea.grantee = p_role
        ORDER BY grantee, object_scope, privilege;
    END;
    $func$;
    ';

    -- Execute the dynamically constructed SQL to create the function
    EXECUTE v_sql;
END $$;
--- END FAILED SCRIPT ---
üîÅ Running on pg_poc_restore_cmd...
üìÑ [pg_poc_restore_cmd] /c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/5 other/dba.GetPrivileges.sql
üîó Running: psql -U "jrussell" -h "dba-exp-tst.cluster-clm0vrvchewi.us-east-2.rds.amazonaws.com" -p "5432" -d "pg_poc_restore_cmd" -f "/c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/5 other/dba.GetPrivileges.sql"
psql: error: connection to server at "dba-exp-tst.cluster-clm0vrvchewi.us-east-2.rds.amazonaws.com" (172.31.24.19), port 5432 failed: FATAL:  database "pg_poc_restore_cmd" does not exist
‚ùå ERROR running /c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/5 other/dba.GetPrivileges.sql against pg_poc_restore_cmd
--- FAILED COMMAND ---
psql -U "jrussell" -h "dba-exp-tst.cluster-clm0vrvchewi.us-east-2.rds.amazonaws.com" -p "5432" -d "pg_poc_restore_cmd" -f "/c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/5 other/dba.GetPrivileges.sql"
--- BEGIN FAILED SCRIPT: /c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/5 other/dba.GetPrivileges.sql ---
-- ============================================
-- Function: dynamic schema.GetPrivileges(p_role TEXT DEFAULT '')
-- Purpose: Retrieve role privileges across schemas and database
-- Version-safe: Includes default ACL parsing only if PG >= 140000
-- ============================================
set role dba_team; 

DO $$
DECLARE
    v_sql TEXT;
    v_schema TEXT;
    v_version INT := current_setting('server_version_num')::INT;
BEGIN
    -- Determine the schema for the function based on the current database
    IF current_database() = 'DBA' THEN
        v_schema := 'info';
    ELSIF current_database() IN ('postgres', 'rdsadmin') THEN
        RAISE NOTICE 'Skipping function creation in system DB: %', current_database();
        RETURN; -- Exit if in a system database
    ELSE
        v_schema := 'dba';
    END IF;

    -- Construct the dynamic SQL for creating or replacing the function
    v_sql := '
    CREATE OR REPLACE FUNCTION ' || quote_ident(v_schema) || '.GetPrivileges(p_role TEXT DEFAULT '''')
    RETURNS TABLE (
        object_scope TEXT,
        grantee TEXT,
        privilege TEXT,
        inherited_role TEXT,
        source TEXT
    )
    LANGUAGE plpgsql AS
    $func$
    DECLARE
        v_ver INT := current_setting(''server_version_num'')::INT;
    BEGIN
        RETURN QUERY
        -- CTE to get roles and their directly inherited roles
        WITH inherited_roles AS (
            SELECT
                r.rolname AS role_name,
                string_agg(m.rolname, '','' ORDER BY m.rolname) AS inherited_role
            FROM pg_roles r
            LEFT JOIN pg_auth_members am ON r.oid = am.member
            LEFT JOIN pg_roles m ON am.roleid = m.oid
            GROUP BY r.rolname
        ),
        -- CTE for schema CREATE privileges
        schema_create AS (
            SELECT
                n.nspname::TEXT AS object_scope,
                r.rolname::TEXT AS grantee,
                ''CREATE''::TEXT AS privilege,
                ir.inherited_role,
                ''actual_schema_privilege''::TEXT AS source
            FROM pg_namespace n
            JOIN pg_roles r ON has_schema_privilege(r.rolname, n.oid, ''CREATE'')
            LEFT JOIN inherited_roles ir ON r.rolname = ir.role_name
            WHERE n.nspname NOT LIKE ''pg_%'' AND n.nspname <> ''information_schema''
        ),
        -- CTE for schema USAGE privileges
        schema_usage AS (
            SELECT
                n.nspname::TEXT AS object_scope,
                r.rolname::TEXT AS grantee,
                ''USAGE''::TEXT AS privilege,
                ir.inherited_role,
                ''actual_schema_privilege''::TEXT AS source
            FROM pg_namespace n
            JOIN pg_roles r ON has_schema_privilege(r.rolname, n.oid, ''USAGE'')
            LEFT JOIN inherited_roles ir ON r.rolname = ir.role_name
            WHERE n.nspname NOT LIKE ''pg_%'' AND n.nspname <> ''information_schema''
        ),
        -- CTE for database-level privileges (CREATE, TEMP, CONNECT)
        db_privs AS (
            SELECT
                current_database()::TEXT AS object_scope,
                r.rolname::TEXT AS grantee,
                unnest(string_to_array(
                    TRIM(BOTH '','' FROM
                        CASE WHEN has_database_privilege(r.rolname, current_database(), ''CREATE'') THEN ''CREATE,'' ELSE '''' END ||
                        CASE WHEN has_database_privilege(r.rolname, current_database(), ''TEMP'') THEN ''TEMP,'' ELSE '''' END ||
                        CASE WHEN has_database_privilege(r.rolname, current_database(), ''CONNECT'') THEN ''CONNECT'' ELSE '''' END
                    ), '',''))::TEXT AS privilege,
                ir.inherited_role,
                ''actual_database_privilege''::TEXT AS source
            FROM pg_roles r
            LEFT JOIN inherited_roles ir ON r.rolname = ir.role_name
        ),
        -- CTE to extract raw ACL entries from pg_default_acl for PG 14+
        raw_acls AS (
            SELECT
                pda.defaclnamespace::regnamespace::TEXT AS object_scope,
                (regexp_matches(acl_entry::TEXT, ''^(.+?)=([a-zA-Z]*)/?(.+)?$''))[1]::TEXT AS grantee,
                (regexp_matches(acl_entry::TEXT, ''^(.+?)=([a-zA-Z]*)/?(.+)?$''))[2]::TEXT AS privs_raw
            FROM pg_default_acl pda, unnest(pda.defaclacl) AS acl_entry
            WHERE current_setting(''server_version_num'')::INT >= 140000
        ),
        -- CTE to expand raw ACL characters into full privilege names
        expanded_acls AS (
            SELECT
                ra.object_scope,
                ra.grantee,
                CASE
                    WHEN ra.privs_raw IS NULL THEN NULL
                    ELSE array_to_string(ARRAY(
                        SELECT priv_subquery.privilege FROM (
                            SELECT CASE WHEN ra.privs_raw LIKE ''%a%'' THEN ''INSERT'' END AS privilege
                            UNION ALL SELECT CASE WHEN ra.privs_raw LIKE ''%r%'' THEN ''SELECT'' END
                            UNION ALL SELECT CASE WHEN ra.privs_raw LIKE ''%w%'' THEN ''UPDATE'' END
                            UNION ALL SELECT CASE WHEN ra.privs_raw LIKE ''%d%'' THEN ''DELETE'' END
                            UNION ALL SELECT CASE WHEN ra.privs_raw LIKE ''%D%'' THEN ''TRUNCATE'' END
                            UNION ALL SELECT CASE WHEN ra.privs_raw LIKE ''%x%'' THEN ''REFERENCES'' END
                            UNION ALL SELECT CASE WHEN ra.privs_raw LIKE ''%t%'' THEN ''TRIGGER'' END
                            UNION ALL SELECT CASE WHEN ra.privs_raw LIKE ''%X%'' THEN ''EXECUTE'' END
                        ) AS priv_subquery WHERE priv_subquery.privilege IS NOT NULL ORDER BY priv_subquery.privilege
                    ), '','')
                END AS privilege,
                ir.inherited_role,
                ''default_acl''::TEXT AS source
            FROM raw_acls ra
            LEFT JOIN inherited_roles ir ON ra.grantee = ir.role_name
        )

        -- Combine all privilege types and filter by p_role if provided
        SELECT sc.object_scope, sc.grantee, sc.privilege, sc.inherited_role, sc.source FROM schema_create sc WHERE p_role = '''' OR sc.grantee = p_role
        UNION ALL
        SELECT su.object_scope, su.grantee, su.privilege, su.inherited_role, su.source FROM schema_usage su WHERE p_role = '''' OR su.grantee = p_role
        UNION ALL
        SELECT db.object_scope, db.grantee, db.privilege, db.inherited_role, db.source FROM db_privs db WHERE p_role = '''' OR db.grantee = p_role
        UNION ALL
        SELECT ea.object_scope, ea.grantee, ea.privilege, ea.inherited_role, ea.source FROM expanded_acls ea WHERE p_role = '''' OR ea.grantee = p_role
        ORDER BY grantee, object_scope, privilege;
    END;
    $func$;
    ';

    -- Execute the dynamically constructed SQL to create the function
    EXECUTE v_sql;
END $$;
--- END FAILED SCRIPT ---
üîÅ Running on dba_jcr...
üìÑ [dba_jcr] /c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/5 other/dba.GetPrivileges.sql
üîó Running: psql -U "jrussell" -h "dba-exp-tst.cluster-clm0vrvchewi.us-east-2.rds.amazonaws.com" -p "5432" -d "dba_jcr" -f "/c/GitHub/as-jrussell/Opscenter/Administry_Of_Databases/Postgres/Postgres_Deploy/chmod/Deploy/5 other/dba.GetPrivileges.sql"
SET
DO
‚úÖ All deployments complete. Log: logs/initial_setup_20250805_1030.log
